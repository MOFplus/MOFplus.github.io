

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>molsys.topo &mdash; molsys 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> molsys
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_addon.html">1. Addons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_util.html">2. Utility Modules</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Stuff</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tech_api.html">1. API Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">File Formats</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../file_io.html">1. File I/O</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">molsys</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>molsys.topo</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for molsys.topo</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">string</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mol</span>
<span class="kn">from</span> <span class="nn">molsys.util</span> <span class="k">import</span> <span class="n">cell_manipulation</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">unit_cell</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">elems</span> <span class="k">as</span> <span class="n">elements</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">rotations</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">images</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mol</span> <span class="k">as</span> <span class="n">mol</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">linear_sum_assignment</span> <span class="k">as</span> <span class="n">hungarian</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ase</span> <span class="k">import</span> <span class="n">Atoms</span>
    <span class="kn">from</span> <span class="nn">pyspglib</span> <span class="k">import</span> <span class="n">spglib</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">spg</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">spg</span> <span class="o">=</span> <span class="kc">True</span>


<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span>    <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;molsys&quot;</span><span class="p">)</span>
<span class="c1">#logger.setLevel(logging.DEBUG)</span>
<span class="c1">#fhandler  = logging.FileHandler(&quot;molsys.log&quot;)</span>
<span class="c1">#fhandler.setLevel(logging.DEBUG)</span>
<span class="c1">#shandler  = logging.StreamHandler()</span>
<span class="c1">#shandler.setLevel(logging.INFO)</span>
<span class="c1">#formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;, datefmt=&#39;%m-%d %H:%M&#39;)</span>
<span class="c1">#fhandler.setFormatter(formatter)</span>
<span class="c1">#shandler.setFormatter(formatter)</span>
<span class="c1">#logger.addHandler(fhandler)</span>
<span class="c1">#logger.addHandler(shandler)</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">20000</span><span class="p">)</span>

<span class="n">deg2rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span>
<span class="n">SMALL_DIST</span> <span class="o">=</span> <span class="mf">1.0e-3</span>


<div class="viewcode-block" id="topo"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo">[docs]</a><span class="k">class</span> <span class="nc">topo</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mol</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span> <span class="o">=</span> <span class="kc">True</span>   <span class="c1"># flag to use pconn: keeps the image number along with the bond</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptab</span><span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># extra default for pyspglib</span>
        <span class="k">if</span> <span class="n">spg</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symprec</span> <span class="o">=</span> <span class="n">SMALL_DIST</span>        <span class="c1"># precision in symmetry detection .. pyspglib default of 1.0e-5 seems to be way too small for large systems (in Angstrom)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonhydrogen</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># use only non-hydrogen atoms if True in symmetry detection or any operation</span>
        <span class="k">return</span>

<div class="viewcode-block" id="topo.fromMol"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.fromMol">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromMol</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set self from mol instance&quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="c1">### MINIMUM ATTRIBUTE SETUP ###</span>
        <span class="c1">###TBI: all relevant non-method attributes retrieved ###</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_natoms</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">natoms</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_xyz</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_conn</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_elems</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_atypes</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">atypes</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">t</span></div>

    <span class="c1">###### helper functions #######################</span>

<span class="c1">#RS</span>
<span class="c1"># looks like this is not used anymore ...</span>

<span class="c1">#    def get_distvec2(self, i, j,exclude_self=True):</span>
<span class="c1">#        &quot;&quot;&quot; vector from i to j</span>
<span class="c1">#        This is a tricky bit, because it is needed also for distance detection in the blueprint</span>
<span class="c1">#        where there can be small cell params wrt to the vertex distances.</span>
<span class="c1">#        In other words: i can be bonded to j multiple times (each in a different image)</span>
<span class="c1">#        and i and j could be the same!! &quot;&quot;&quot;</span>
<span class="c1">#        leni = True</span>
<span class="c1">#        lenj = True</span>
<span class="c1">#        try:</span>
<span class="c1">#            l=len(i)</span>
<span class="c1">#            if l &gt; 1:</span>
<span class="c1">#                ri = np.array(i)</span>
<span class="c1">#            else:</span>
<span class="c1">#                leni = False</span>
<span class="c1">#                ri = self.xyz[i]</span>
<span class="c1">#        except:</span>
<span class="c1">#            ri = self.xyz[i]</span>
<span class="c1">#        try:</span>
<span class="c1">#            l=len(j)</span>
<span class="c1">#            if l &gt; 1:</span>
<span class="c1">#                rj = np.array(j)</span>
<span class="c1">#            else:</span>
<span class="c1">#                rj = self.xyz[j]</span>
<span class="c1">#        except:</span>
<span class="c1">#            rj = self.xyz[j]</span>
<span class="c1">#            lenj = False</span>
<span class="c1">#        if 1:</span>
<span class="c1">#            all_rj = rj + self.images_cellvec</span>
<span class="c1">#            all_r = all_rj - ri</span>
<span class="c1">#            all_d = np.sqrt(np.add.reduce(all_r*all_r,1))</span>
<span class="c1">#            d_sort = np.argsort(all_d)</span>
<span class="c1">#            if exclude_self and (np.linalg.norm(ri-rj) &lt;= 0.001):</span>
<span class="c1">#                d_sort = d_sort[1:]</span>
<span class="c1">#            closest = d_sort[0]</span>
<span class="c1">#            closest=[closest]</span>
<span class="c1">#            if (abs(all_d[closest[0]]-all_d[d_sort[1]]) &lt; SMALL_DIST):</span>
<span class="c1">#                for k in d_sort[1:]:</span>
<span class="c1">#                    if (abs(all_d[d_sort[0]]-all_d[k]) &lt; SMALL_DIST):</span>
<span class="c1">#                        closest.append(k)</span>
<span class="c1">#            d = all_d[closest[0]]</span>
<span class="c1">#            r = all_r[closest[0]]</span>
<span class="c1">#        return d, r, closest</span>

    <span class="c1"># thes following functions rely on an exisiting connectivity conn (and pconn)</span>

<span class="c1">#    def get_neighb_coords(self, i, ci):</span>
<span class="c1">#        &quot;&quot;&quot; returns coordinates of atom bonded to i which is ci&#39;th in bond list &quot;&quot;&quot;</span>
<span class="c1">#        j = self.conn[i][ci]</span>
<span class="c1">#        rj = self.xyz[j].copy()</span>
<span class="c1">#        if self.periodic:</span>
<span class="c1">#            if self.use_pconn:</span>
<span class="c1">#                img = self.pconn[i][ci]</span>
<span class="c1">#                rj += np.dot(img, self.cell)</span>
<span class="c1">#            else:</span>
<span class="c1">#                all_rj = rj + self.images_cellvec</span>
<span class="c1">#                all_r = all_rj - self.xyz[i]</span>
<span class="c1">#                all_d = np.sqrt(np.add.reduce(all_r*all_r,1))</span>
<span class="c1">#                closest = np.argsort(all_d)[0]</span>
<span class="c1">#                return all_rj[closest]</span>
<span class="c1">#        return rj</span>
<span class="c1">#</span>
<span class="c1">#    def get_neighb_dist(self, i, ci):</span>
<span class="c1">#        &quot;&quot;&quot; returns coordinates of atom bonded to i which is ci&#39;th in bond list &quot;&quot;&quot;</span>
<span class="c1">#        ri = self.xyz[i]</span>
<span class="c1">#        j = self.conn[i][ci]</span>
<span class="c1">#        rj = self.xyz[j].copy()</span>
<span class="c1">#        if self.periodic:</span>
<span class="c1">#            if self.use_pconn:</span>
<span class="c1">#                img = self.pconn[i][ci]</span>
<span class="c1">#                rj += np.dot(img, self.cell)</span>
<span class="c1">#            else:</span>
<span class="c1">#                all_rj = rj + self.images_cellvec</span>
<span class="c1">#                all_r = all_rj - self.xyz[i]</span>
<span class="c1">#                all_d = np.sqrt(np.add.reduce(all_r*all_r,1))</span>
<span class="c1">#                closest = np.argsort(all_d)[0]</span>
<span class="c1">#                return all_rj[closest]</span>
<span class="c1">#        dr = ri-rj</span>
<span class="c1">#        d = np.sqrt(np.sum(dr*dr))</span>
<span class="c1">#        return d</span>

    <span class="c1">######## manipulations in particular for blueprints</span>

<span class="c1">#    def make_supercell(self, supercell):</span>
<span class="c1">#        self.supercell = tuple(supercell)</span>
<span class="c1">#        logger.info(&#39;Generating %i x %i x %i supercell&#39; % self.supercell)</span>
<span class="c1">#        img = [np.array(i) for i in images.tolist()]</span>
<span class="c1">#        ntot = np.prod(supercell)</span>
<span class="c1">#        nat = copy.deepcopy(self.natoms)</span>
<span class="c1">#        nx,ny,nz = self.supercell[0],self.supercell[1],self.supercell[2]</span>
<span class="c1">#        pconn = [copy.deepcopy(self.pconn) for i in range(ntot)]</span>
<span class="c1">#        conn =  [copy.deepcopy(self.conn) for i in range(ntot)]</span>
<span class="c1">#        xyz =   [copy.deepcopy(self.xyz) for i in range(ntot)]</span>
<span class="c1">#        elems = copy.deepcopy(self.elems)</span>
<span class="c1">#        left,right,front,back,bot,top =  [],[],[],[],[],[]</span>
<span class="c1">#        neighs = [[] for i in range(6)]</span>
<span class="c1">#        iii = []</span>
<span class="c1">#        for iz in range(nz):</span>
<span class="c1">#            for iy in range(ny):</span>
<span class="c1">#                for ix in range(nx):</span>
<span class="c1">#                    ixyz = ix+nx*iy+nx*ny*iz</span>
<span class="c1">#                    iii.append(ixyz)</span>
<span class="c1">#                    if ix == 0   : left.append(ixyz)</span>
<span class="c1">#                    if ix == nx-1: right.append(ixyz)</span>
<span class="c1">#                    if iy == 0   : bot.append(ixyz)</span>
<span class="c1">#                    if iy == ny-1: top.append(ixyz)</span>
<span class="c1">#                    if iz == 0   : front.append(ixyz)</span>
<span class="c1">#                    if iz == nz-1: back.append(ixyz)</span>
<span class="c1">#        for iz in range(nz):</span>
<span class="c1">#            for iy in range(ny):</span>
<span class="c1">#                for ix in range(nx):</span>
<span class="c1">#                    ixyz = ix+nx*iy+nx*ny*iz</span>
<span class="c1">#                    dispvect = np.sum(self.cell*np.array([ix,iy,iz])[:,np.newaxis],axis=0)</span>
<span class="c1">#                    xyz[ixyz] += dispvect</span>
<span class="c1">#</span>
<span class="c1">#                    i = copy.copy(ixyz)</span>
<span class="c1">#                    for cc in range(len(conn[i])):</span>
<span class="c1">#                        for c in range(len(conn[i][cc])):</span>
<span class="c1">#                            if (img[13] == pconn[i][cc][c]).all():</span>
<span class="c1">#                                #conn[i][cc][c] += ixyz*nat</span>
<span class="c1">#                                conn[i][cc][c] = int( conn[i][cc][c] + ixyz*nat )</span>
<span class="c1">#                                pconn[i][cc][c] = np.array([0,0,0])</span>
<span class="c1">#                            else:</span>
<span class="c1">#                                px,py,pz     = pconn[i][cc][c][0],pconn[i][cc][c][1],pconn[i][cc][c][2]</span>
<span class="c1">#                                #print(px,py,pz)</span>
<span class="c1">#                                iix,iiy,iiz  = (ix+px)%nx, (iy+py)%ny, (iz+pz)%nz</span>
<span class="c1">#                                iixyz= iix+nx*iiy+nx*ny*iiz</span>
<span class="c1">#                                conn[i][cc][c] = int( conn[i][cc][c] + iixyz*nat )</span>
<span class="c1">#                                pconn[i][cc][c] = np.array([0,0,0])</span>
<span class="c1">#                                if ((px == -1) and (left.count(ixyz)  != 0)): pconn[i][cc][c][0] = -1</span>
<span class="c1">#                                if ((px ==  1) and (right.count(ixyz) != 0)): pconn[i][cc][c][0] =  1</span>
<span class="c1">#                                if ((py == -1) and (bot.count(ixyz)   != 0)): pconn[i][cc][c][1] = -1</span>
<span class="c1">#                                if ((py ==  1) and (top.count(ixyz)   != 0)): pconn[i][cc][c][1] =  1</span>
<span class="c1">#                                if ((pz == -1) and (front.count(ixyz) != 0)): pconn[i][cc][c][2] = -1</span>
<span class="c1">#                                if ((pz ==  1) and (back.count(ixyz)  != 0)): pconn[i][cc][c][2] =  1</span>
<span class="c1">#                                #print(px,py,pz)</span>
<span class="c1">#        self.conn, self.pconn, self.xyz = [],[],[]</span>
<span class="c1">#        for cc in conn:</span>
<span class="c1">#            for c in cc:</span>
<span class="c1">#                self.conn.append(c)</span>
<span class="c1">#        for pp in pconn:</span>
<span class="c1">#            for p in pp:</span>
<span class="c1">#                self.pconn.append(p)</span>
<span class="c1">#        self.natoms = nat*ntot</span>
<span class="c1">#        self.xyz = np.array(xyz).reshape(nat*ntot,3)</span>
<span class="c1">#        self.cellparams[0:3] *= np.array(self.supercell)</span>
<span class="c1">#        self.cell *= np.array(self.supercell)[:,np.newaxis]</span>
<span class="c1">#        self.inv_cell = np.linalg.inv(self.cell)</span>
<span class="c1">#        self.elems *= ntot</span>
<span class="c1">#        self.atypes*=ntot</span>
<span class="c1">#        self.images_cellvec = np.dot(images, self.cell)</span>
<span class="c1">#        return xyz,conn,pconn</span>

    <span class="c1">######### connectivity things #################################</span>

<div class="viewcode-block" id="topo.detect_conn"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.detect_conn">[docs]</a>    <span class="k">def</span> <span class="nf">detect_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pconn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_rad_buffer</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">pconn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">d</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">imgi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distvec</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">bond</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">fixed_cutoff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">&lt;</span><span class="n">fixed_cutoff</span><span class="p">:</span> <span class="n">bond</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">covradi</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">cov_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">covradj</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">cov_radii</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">d</span><span class="o">&lt;</span><span class="p">(</span><span class="n">covradi</span><span class="o">+</span><span class="n">covradj</span><span class="o">+</span><span class="n">cov_rad_buffer</span><span class="p">)</span> <span class="p">:</span> <span class="n">bond</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># exclude pairs testing</span>
                <span class="k">if</span> <span class="n">exclude_pairs</span> <span class="ow">and</span> <span class="n">bond</span><span class="p">:</span>
                    <span class="n">el_p1</span><span class="p">,</span><span class="n">el_p2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]),(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">expair</span> <span class="ow">in</span> <span class="n">exclude_pairs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">expair</span> <span class="o">==</span> <span class="n">el_p1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">expair</span> <span class="o">==</span> <span class="n">el_p2</span><span class="p">):</span>
                            <span class="n">bond</span><span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">bond</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgi</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in connectivity detection: use pconn!!!&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">imgi</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
                            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span></div>
    
<span class="c1">#    def detect_conn_by_coord_WRONG(self, pconn=False, exclude_pairs=None):</span>
<span class="c1">#        assert len(self.ncoord) == self.natoms , &quot;number of coordination per vertex must be set&quot;</span>
<span class="c1">#        self.use_pconn = pconn</span>
<span class="c1">#        self.set_empty_conn()</span>
<span class="c1">#        ncoord = self.ncoord[:]</span>
<span class="c1">#        if self.use_pconn: self.set_empty_pconn()</span>
<span class="c1">#        for i in xrange(self.natoms):</span>
<span class="c1">#            dists = []</span>
<span class="c1">#            js = []</span>
<span class="c1">#            imgs = []</span>
<span class="c1">#            maxcoord = ncoord[i]</span>
<span class="c1">#            if maxcoord == 0:</span>
<span class="c1">#                continue</span>
<span class="c1">#            for j in xrange(i+1,self.natoms):</span>
<span class="c1">#                d,r,imgi=self.get_distvec2(i,j)</span>
<span class="c1">#                ### exclude w/ exclude pairs</span>
<span class="c1">#                excluded = False</span>
<span class="c1">#                if exclude_pairs:</span>
<span class="c1">#                    # delete excluded pairs</span>
<span class="c1">#                    el_p1,el_p2 = (self.elems[i], self.elems[j]),(self.elems[j], self.elems[i])</span>
<span class="c1">#                    for expair in exclude_pairs:</span>
<span class="c1">#                        if (expair == el_p1) or (expair == el_p2):</span>
<span class="c1">#                            excluded = True</span>
<span class="c1">#                            break</span>
<span class="c1">#                if not excluded:</span>
<span class="c1">#                    dists.append(d)</span>
<span class="c1">#                    js.append(j)</span>
<span class="c1">#                    imgs.append(imgi)</span>
<span class="c1">#            ### INIT np.array</span>
<span class="c1">#            dists = np.array(dists)</span>
<span class="c1">#            js = np.array(js)</span>
<span class="c1">#            imgs = np.array(imgs)</span>
<span class="c1">#            ### GET SORTING INDICES</span>
<span class="c1">#            sortind = np.argsort(dists)</span>
<span class="c1">#            ### ARRANGE BY SORTING INDICES</span>
<span class="c1">#            dists = dists[sortind]</span>
<span class="c1">#            js = js[sortind]</span>
<span class="c1">#            imgs = imgs[sortind]</span>
<span class="c1">#            ### GET MAX IND UNTILL BOND</span>
<span class="c1">#            imgslen = map(len,imgs)</span>
<span class="c1">#            imgscum = np.cumsum(imgslen)</span>
<span class="c1">#            try:</span>
<span class="c1">#                tillind = np.where(imgscum == maxcoord)[0][0] + 1</span>
<span class="c1">#            except IndexError:</span>
<span class="c1">#                print(self.name, self.ncoord[i], maxcoord)</span>
<span class="c1">#                print(self.ncoord)</span>
<span class="c1">#                print(ncoord)</span>
<span class="c1">#                print(imgslen, imgscum)</span>
<span class="c1">#                break</span>
<span class="c1">#            for k,j in enumerate(js[:tillind]):</span>
<span class="c1">#                if imgslen[k] &gt; 1 and not self.use_pconn:</span>
<span class="c1">#                    raise ValueError(&quot;Error in connectivity detection: use pconn!!!&quot;)</span>
<span class="c1">#                for ii in imgs[k]:</span>
<span class="c1">#                    self.conn[i].append(j)</span>
<span class="c1">#                    self.conn[j].append(i)</span>
<span class="c1">#                    if self.use_pconn:</span>
<span class="c1">#                        image = images[ii]</span>
<span class="c1">#                        self.pconn[i].append(image)</span>
<span class="c1">#                        self.pconn[j].append(image*-1)</span>
<span class="c1">#                ncoord[j] -= imgslen[k]</span>
<span class="c1">#        return</span>
    
<div class="viewcode-block" id="topo.detect_conn_by_coord"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.detect_conn_by_coord">[docs]</a>    <span class="k">def</span> <span class="nf">detect_conn_by_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TBI: EXCLUDE_PAIRS&quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;Detects connectivity by coordination number of the vertices/atoms</span>
<span class="sd">        :Variables:</span>
<span class="sd">            - self.natoms = N (int): number of atoms</span>
<span class="sd">            - self.ncoord (list of int&#39;s): coordination number per vertex/atom</span>
<span class="sd">            - dists (NxN float np.triu array): distances per distinct couple of vertices</span>
<span class="sd">            - imgs (NxN list np.triu array): (periodic) images per bond</span>
<span class="sd">            - nimgs (NxN int np.triu array): number of images per bond</span>
<span class="sd">            - maximgs (N int array): max number of images per bond per atom</span>
<span class="sd">                N.B.: 1 where 0</span>
<span class="sd">            - rimgs (NxN int np.tril array): remainder nimgs - maximgs</span>
<span class="sd">            - lnimgs (N list of lists): default addend list for possible bonds (=0)</span>
<span class="sd">            - lrimgs (N list of lists): very-high addend list for impossible bonds (&gt;&gt;0, e.g. sys.maxint)</span>
<span class="sd">                N.B.: impossible bonds are self bonds, inverse-cross bonds, and bonds that are non-detected as periodic images (hence rimgs)</span>
<span class="sd">            - aimgs (NxM int array): augmented addend cost array for images</span>
<span class="sd">            - adists (NxM float array): augmented dists array</span>
<span class="sd">                N.B.: adists == 0 where aimgs returns &quot;impossible&quot; cost</span>
<span class="sd">                else: returns default cost</span>
<span class="sd">                N.B.B.: aimgs == very-high cost where adists CAN BE != 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">240</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncoord</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">,</span>\
            <span class="s2">&quot;number of coordination per vertex must be set&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span> <span class="o">=</span> <span class="n">pconn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_empty_conn</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_empty_pconn</span><span class="p">()</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>
        <span class="n">imgs</span><span class="o">.</span><span class="n">fill</span><span class="p">([])</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="n">nimgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">rdummy</span><span class="p">,</span> <span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distvec</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="n">nimgs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="n">imgs</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">nimgs</span> <span class="o">=</span> <span class="n">nimgs</span><span class="o">.</span><span class="n">T</span><span class="p">[:]</span>
        <span class="c1">### ### ### ### ###</span>
        <span class="kn">from</span> <span class="nn">pyscipopt</span> <span class="k">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">quicksum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="s2">&quot;getConnByCoord&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">entries</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span> <span class="c1">#last is empty</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">addVar</span><span class="p">(</span>
                        <span class="n">vtype</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;e(</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">imgs_redundant</span> <span class="o">=</span> <span class="n">imgs</span> <span class="o">+</span> <span class="n">imgs</span><span class="o">.</span><span class="n">T</span>
        <span class="n">imgs_mod</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imgs_redundant</span><span class="p">):</span>
            <span class="n">rowmod</span> <span class="o">=</span> <span class="p">[[[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span> <span class="k">if</span> <span class="n">entries</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span> <span class="k">else</span> <span class="p">[[(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">j</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">entries</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)]</span>
            <span class="n">rowmod</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rowmod</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span><span class="p">[]],[])</span>
            <span class="n">rowmod</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rowmod</span><span class="p">]</span>
            <span class="n">imgs_mod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowmod</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">addCons</span><span class="p">(</span>
                    <span class="n">quicksum</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rowmod</span> <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncoord</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;RespectCoordination(c[</span><span class="si">%i</span><span class="s2">]==</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ncoord</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failure! &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="n">model</span><span class="o">.</span><span class="n">setObjective</span><span class="p">(</span>
            <span class="n">quicksum</span><span class="p">(</span> <span class="n">dists</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">e</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">sense</span><span class="o">=</span><span class="s2">&quot;minimize&quot;</span>
        <span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">hideOutput</span><span class="p">()</span>
        <span class="n">model</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">getStatus</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failure! Not optimized! &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">pbonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pbonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">pimages</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pbonds</span><span class="p">)</span>
        <span class="n">pconn</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pimages</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ctab</span><span class="p">(</span> <span class="n">conn</span><span class="p">,</span>  <span class="n">conn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ptab</span><span class="p">(</span><span class="n">pconn</span><span class="p">,</span> <span class="n">pconn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#self.model = model</span>
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="topo.remove_duplicates"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.remove_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="n">SMALL_DIST</span><span class="p">):</span>
        <span class="n">badlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">d</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">imgi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distvec</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">:</span>
                    <span class="n">badlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">badlist</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">new_xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">new_elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_xyz</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">new_elems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span> <span class="o">=</span> <span class="n">new_atypes</span>
        <span class="k">return</span></div>

    <span class="c1">#def add_pconn(self):</span>
    <span class="c1">#    &quot;&quot;&quot; with the method detect_conn the connectivity is detected from a distance search</span>
    <span class="c1">#        if a connectivity is read via a tinker file there is no pconn present.</span>
    <span class="c1">#        with this metod it is added for the use with weaver2 &quot;&quot;&quot;</span>
    <span class="c1">#    self.use_pconn= True</span>
    <span class="c1">#    self.pimages = []</span>
    <span class="c1">#    self.pconn = []</span>
    <span class="c1">#    for i,c in enumerate(self.conn):</span>
    <span class="c1">#        atoms_pconn = []</span>
    <span class="c1">#        atoms_image = []</span>
    <span class="c1">#        for ji, j in enumerate(c):</span>
    <span class="c1">#            # If an atom or vertex is connected to another one multiple times (in an image), this</span>
    <span class="c1">#            # will be visible in the self.conn attribute, where the same neighbour will be listed</span>
    <span class="c1">#            # multiple times.</span>
    <span class="c1">#            # Sometimes, the distances are a bit different from each other, and in this case, we</span>
    <span class="c1">#            # have to increase the threshold, until the get_distvec function will find all imgis.</span>
    <span class="c1">#            n_conns = c.count(j)</span>
    <span class="c1">#            t = 0.01</span>
    <span class="c1">#            while True:</span>
    <span class="c1">#                d,r,imgi = self.get_distvec(i,j,thresh=t)</span>
    <span class="c1">#                t += 0.01</span>
    <span class="c1">#                if n_conns == len(imgi):</span>
    <span class="c1">#                    break</span>
    <span class="c1">#            if len(imgi) == 1:</span>
    <span class="c1">#                # only one neighbor .. all is fine</span>
    <span class="c1">#                atoms_pconn.append(images[imgi[0]])</span>
    <span class="c1">#                atoms_image.append(imgi[0])</span>
    <span class="c1">#            else:</span>
    <span class="c1">#                # we need to assign an image to each connection</span>
    <span class="c1">#                # if an atom is connected to another atom twice this means it must be another</span>
    <span class="c1">#                # image</span>
    <span class="c1">#                for ii in imgi:</span>
    <span class="c1">#                    # test if this image is not used for this atom .. then we can use it</span>
    <span class="c1">#                    if atoms_image.count(ii)==0:</span>
    <span class="c1">#                        atoms_image.append(ii)</span>
    <span class="c1">#                        atoms_pconn.append(images[ii])</span>
    <span class="c1">#                    else:</span>
    <span class="c1">#                        # ok, we have this image already</span>
    <span class="c1">#                        use_it = True</span>
    <span class="c1">#                        #print(c, &quot;=&gt;&quot;, j)</span>
    <span class="c1">#                        #print(atoms_image)</span>
    <span class="c1">#                        for k, iii in enumerate(atoms_image):</span>
    <span class="c1">#                            #print(&#39;k&#39;,k)</span>
    <span class="c1">#                            if (iii == ii) and (c[k] == j): use_it=False</span>
    <span class="c1">#                        if use_it:</span>
    <span class="c1">#                            atoms_image.append(ii)</span>
    <span class="c1">#                            atoms_pconn.append(images[ii])</span>
    <span class="c1">#        self.pimages.append(atoms_image)</span>
    <span class="c1">#        self.pconn.append(atoms_pconn)</span>
    <span class="c1">#    return</span>

        <span class="c1"># &#39;na&#39;,lower(label),xyz,i,j)</span>
<div class="viewcode-block" id="topo.insert_atom"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.insert_atom">[docs]</a>    <span class="k">def</span> <span class="nf">insert_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">aty</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">xyz</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aty</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1">#self.natoms += 1</span>
        <span class="c1">#print(i, ci)</span>
        <span class="c1">#print(j, cj)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c1">#self.pconn.append([])</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
            <span class="n">pci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ci</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="n">pcj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cj</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">ci</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">cj</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">ci</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">)</span>
        <span class="n">cj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span><span class="n">pci</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#print(&quot;end of insert .. conn:&quot;)</span>
        <span class="c1">#print(self.conn)</span>
        <span class="k">return</span></div>


    <span class="c1">#RS !!! HACK !!! this is not pretty but becasue of the pconn here in topo we need another add_atom</span>
    <span class="c1">#maybe we can just call the add_atom of the mol parent class and just add the pconn stuff here.</span>
<div class="viewcode-block" id="topo.add_atom"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.add_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">atype</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span><span class="o">==</span> <span class="nb">str</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atype</span><span class="p">)</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">xyz</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">-</span><span class="mi">1</span></div>




<div class="viewcode-block" id="topo.delete_atom"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.delete_atom">[docs]</a>    <span class="k">def</span> <span class="nf">delete_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bad</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; deletes an atom and its connections and fixes broken indices of all other atoms &#39;&#39;&#39;</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_conn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_pconn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">bad</span><span class="p">:</span>
                <span class="n">new_xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">new_elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_pconn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_conn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">new_conn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">new_conn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">new_conn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bad</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_xyz</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">new_elems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span> <span class="o">=</span> <span class="n">new_atypes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_conn</span><span class="p">)):</span>
            <span class="c1">#try:</span>
                <span class="c1">#len(new_conn[i])</span>
            <span class="c1">#except:</span>
                <span class="c1">#new_conn[i] = [new_conn[i]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_conn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">new_conn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bad</span><span class="p">:</span>
                    <span class="n">new_conn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">new_conn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">new_conn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span> <span class="o">=</span> <span class="n">new_pconn</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.add_conn"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.add_conn">[docs]</a>    <span class="k">def</span> <span class="nf">add_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add a connection between a1 and a2 (in both directions)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not add bonds to systems with pconn - well, we can fix this ;) &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="n">d</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">imgi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distvec</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">imgi</span><span class="p">])</span>
        <span class="n">d</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">imgi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distvec</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">a1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">imgi</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;pconn may not be properly updated!!!&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.delete_conn"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.delete_conn">[docs]</a>    <span class="k">def</span> <span class="nf">delete_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">el1</span><span class="p">,</span><span class="n">el2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; removes the connection between two atoms</span>
<span class="sd">        :Parameters:</span>
<span class="sd">            - el1,el2 : indices of the atoms whose connection is to be removed&#39;&#39;&#39;</span>
        <span class="n">idx1</span><span class="p">,</span><span class="n">idx2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">el1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el2</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">el2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">el1</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">el2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">el2</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">el1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">el1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">el2</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;pconn may not be properly updated!!!&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.set_elems_by_coord_number"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_elems_by_coord_number">[docs]</a>    <span class="k">def</span> <span class="nf">set_elems_by_coord_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elements</span><span class="o">.</span><span class="n">topotypes</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_elems</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
        <span class="k">return</span></div>

<span class="c1">############# Plotting</span>

<div class="viewcode-block" id="topo.plot"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">bonds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">axes3d</span><span class="p">,</span> <span class="n">Axes3D</span> 
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">200</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">figaspect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="c1">#ax = fig.add_subplot(111, projection=&#39;3d&#39;)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">Axes3D</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="n">atd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">aa</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">))):</span>
            <span class="n">atd</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">aa</span><span class="p">:</span><span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">]})</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">atd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">2</span><span class="p">]],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xyznew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">xyznew</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]],[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">2</span><span class="p">]],</span><span class="n">color</span><span class="o">=</span><span class="n">atd</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scell</span><span class="p">:</span>
            <span class="n">xyz3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_333</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">xyz3</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz3</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyz3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">xyz3</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">xyz3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">xyz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">xx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">atd</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">minbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])])</span>
        <span class="n">maxbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">auto_scale_xyz</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxbound</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxbound</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxbound</span><span class="p">])</span>
        <span class="c1">#ax.scatter(xyz1[:,0],xyz1[:,1],xyz1[:,2],color=&#39;k&#39;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<span class="c1">########## additional stuff for edge coloring ############################################</span>

<div class="viewcode-block" id="topo.color_edges"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.color_edges">[docs]</a>    <span class="k">def</span> <span class="nf">color_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">maxstep</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">nprint</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">penref</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.0e-3</span><span class="p">,</span> <span class="n">MC</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        wrapper to search for a zero penalty solution of edge coloring. An initial coloring is generated</span>
<span class="sd">        randomly and a flipMC run is started ... if no zero penalty is found after maxsteps it is repeated ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MC</span> <span class="o">=</span> <span class="n">MC</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">converged</span> <span class="ow">and</span> <span class="p">(</span><span class="n">niter</span><span class="o">&lt;</span><span class="n">maxiter</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_color_edges</span><span class="p">(</span><span class="n">proportions</span><span class="p">,</span> <span class="n">MC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MC</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_flip</span><span class="p">(</span><span class="n">maxstep</span><span class="p">,</span> <span class="n">nprint</span><span class="o">=</span><span class="n">nprint</span><span class="p">,</span> <span class="n">penref</span><span class="o">=</span><span class="n">penref</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">converged</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">niter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**********************************************************************&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;edge coloring is convereged !!&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;final penalty is </span><span class="si">%12.6f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="topo.init_color_edges"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.init_color_edges">[docs]</a>    <span class="k">def</span> <span class="nf">init_color_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportions</span><span class="o">=</span><span class="p">[],</span> <span class="n">colors</span><span class="o">=</span><span class="p">[],</span> <span class="n">bcolors</span><span class="o">=</span><span class="p">[],</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.0e-3</span><span class="p">,</span> <span class="n">MC</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generate datastructures for edge coloring and set up random</span>
<span class="sd">        the proportions are a list or tuple of integer.</span>
<span class="sd">        the length determines the number of colors, the numbers are the multiples</span>
<span class="sd">        one integer should be always 1.</span>
<span class="sd">        so for example proportions=[2,1] generates a two color system (red, blue)</span>
<span class="sd">        with 2 red and 1 blue ... this means the total number of edges inthe periodic net must</span>
<span class="sd">        be a multiple of 3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MC</span> <span class="o">=</span> <span class="n">MC</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">proportions</span><span class="p">),</span><span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">)),</span><span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bcolors</span><span class="p">)))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>\
            <span class="s2">&quot;either proportions or colors or bcolors must be non-empty&quot;</span>
        <span class="c1">### generate the list of bonds only &quot;upwards&quot; bonds (i1&lt;i2) are stored</span>
        <span class="n">blist</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ci</span> <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span> <span class="p">]</span>
        <span class="c1">### convert blist into numpy array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">blist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors2proportions</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors2bcolors</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">list</span><span class="p">(</span><span class="n">bcolors</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolors2colors</span><span class="p">(</span><span class="n">bcolors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors2proportions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">###get colors via proportions, set proportions by argument</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportions2colors</span><span class="p">(</span><span class="n">proportions</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors2bcolors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MC</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncolors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop</span><span class="p">)</span>
        <span class="c1">### set up penalty table (per vertex)</span>
        <span class="c1">### defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sum_fact</span>    <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orient_fact</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="c1">### self.colpen_sumrule = self.natoms*[4.0]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
        <span class="c1">### set up the scalmat array for all vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_scalprod_mats</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totpen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.flip_color"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.flip_color">[docs]</a>    <span class="k">def</span> <span class="nf">flip_color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        does one color flip and computes the new penalty</span>
<span class="sd">        the old settings are kept</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get bond A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bondA</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colA</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">]</span>
        <span class="n">vert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">peninit</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="c1"># get bond B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colA</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">colA</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">colB</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bondB</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">]</span>
        <span class="n">vert</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">peninit</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">3</span><span class="p">]]]</span>
        <span class="n">peninit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peninit</span><span class="p">)</span>
        <span class="c1"># now flip the colors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colA</span>
        <span class="c1"># now correct entries in bcolors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bcol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bcol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">)</span>
        <span class="c1"># compute penalty of he four affected vertices only</span>
        <span class="n">pennew</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">pennew</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pennew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pennew</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed_vert</span> <span class="o">=</span> <span class="n">vert</span>
        <span class="c1"># compute delta in penalty</span>
        <span class="n">delta_pen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pennew</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">-</span><span class="n">peninit</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># print(&quot;flipped colors of bonds %3d and %3d (vertices: %20s) -- delta penalty: %10.3f&quot; % (self.bondA, self.bondB, str(vert), delta_pen))</span>
        <span class="k">return</span> <span class="n">delta_pen</span></div>

<div class="viewcode-block" id="topo.unflip_colors"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.unflip_colors">[docs]</a>    <span class="k">def</span> <span class="nf">unflip_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        call this directly after a flip to put everything back</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bcol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bcol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bondB</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.accept_flip"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.accept_flip">[docs]</a>    <span class="k">def</span> <span class="nf">accept_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        call this directly after flip to keep the flip</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changed_vert</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pennew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totpen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.run_flip"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.run_flip">[docs]</a>    <span class="k">def</span> <span class="nf">run_flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxstep</span><span class="p">,</span> <span class="n">nprint</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">penref</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.0e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        run a MC with color flips as moves for maxstep or until the total penalty</span>
<span class="sd">        is below thresh. the virtual &quot;temperature&quot; or reference energy for the acceptance</span>
<span class="sd">        (kT) is in the same unit as the penalty and is given as penref</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            - maxstep : maximum number of MC steps</span>
<span class="sd">            - nprint  : number of steps after which a printout is made [100]</span>
<span class="sd">            - penref  : reference penalty for the MC aceptance criterion exp(-pen/penref) [0.2]</span>
<span class="sd">            - thresh  : threshold under which convergence is assumed (zero penalty is not always reached for orientation penalty) [1.0e-3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totpen</span><span class="o">&gt;</span><span class="n">thresh</span><span class="p">):</span>
            <span class="n">dpen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_color</span><span class="p">()</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">dpen</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dpen</span><span class="o">/</span><span class="n">penref</span><span class="p">)</span>
                <span class="c1">#print(&quot;dpen %10.5f prob %10.5f&quot; %(dpen, prob))</span>
                <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">prob</span><span class="p">:</span>
                    <span class="n">accept</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">accept_flip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unflip_colors</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">step</span><span class="o">%</span><span class="n">nprint</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;step: </span><span class="si">%7d</span><span class="s2"> ; penalty </span><span class="si">%10.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">totpen</span><span class="p">))</span>
            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">step</span><span class="o">&lt;</span><span class="n">maxstep</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converged after </span><span class="si">%7d</span><span class="s2"> steps with penalty </span><span class="si">%10.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">totpen</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;last delta_pen was </span><span class="si">%10.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dpen</span><span class="p">)</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not converged!!!&quot;</span><span class="p">)</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">converged</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">totpen</span><span class="p">)</span></div>

<span class="c1">### GRAPH TO MOL METHODS #######################################################</span>
<div class="viewcode-block" id="topo.add_vertex_on_color"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.add_vertex_on_color">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex_on_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">lelem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">laty</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lelem</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">laty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> \
            <span class="s2">&quot;add_vertex_on_color expects a triplet or alist of nested triplets&quot;</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="s1">&#39;__iter__&#39;</span><span class="p">),</span> <span class="n">errmsg</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">errmsg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vertex_on_color</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">xyz_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighb_coords</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ci</span><span class="p">)</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">xyz_j</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert_atom</span><span class="p">(</span><span class="n">lelem</span><span class="p">,</span> <span class="n">laty</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.col2vex"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.col2vex">[docs]</a>    <span class="k">def</span> <span class="nf">col2vex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sele</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lelem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">laty</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;from colors to vertices, returns molsys.mol instance</span>
<span class="sd">        original vertices are kept the same</span>
<span class="sd">        edges are condensed in the baricenter&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sele</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncolors</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">nbonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span>
            <span class="n">ba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indexcol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">==</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sele</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">###since bool arrays, here &quot;sum&quot; means &quot;or&quot;</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">indexcol</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">indexcol</span><span class="p">]</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sele</span><span class="p">)</span>
            <span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">ba</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][</span><span class="n">indexcol</span><span class="p">]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">indexcol</span><span class="p">]</span>
        <span class="n">xyz_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ba</span><span class="p">]</span>
        <span class="n">xyz_c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbonds</span><span class="p">):</span>
            <span class="n">bci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">ba</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">xyz_ic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighb_coords</span><span class="p">(</span><span class="n">ba</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bci</span><span class="p">)</span>
            <span class="n">xyz_c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz_ic</span><span class="p">)</span>
        <span class="n">xyz_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz_c</span><span class="p">)</span> <span class="o">+</span> <span class="n">xyz_a</span>
        <span class="n">xyz_c</span> <span class="o">*=</span> <span class="o">.</span><span class="mi">5</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">fromArray</span><span class="p">(</span><span class="n">xyz_c</span><span class="p">)</span>
        <span class="c1">### DEFAULT ASSIGNMENT</span>
        <span class="k">if</span> <span class="n">lelem</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">laty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">laty</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">lowercase</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;kbabcdefghijklmnopqrstuvwxyz&#39;</span><span class="p">)</span>
            <span class="n">lelem</span> <span class="o">=</span> <span class="p">[</span><span class="n">lowercase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">laty</span><span class="p">]</span>
            <span class="n">laty</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">laty</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">lelem</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">laty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lelem and laty must be both either None or ndarrays&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lelem</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncol</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">laty</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len of sele, lelem and laty must be the same!</span><span class="se">\n</span><span class="s2">sele:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s2">lelem:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s2">laty:</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sele</span><span class="p">,</span> <span class="n">lelem</span><span class="p">,</span> <span class="n">laty</span><span class="p">))</span>
        <span class="n">lelem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lelem</span><span class="p">)</span>
        <span class="n">laty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">laty</span><span class="p">)</span>
        <span class="n">m</span><span class="o">.</span><span class="n">set_elems</span><span class="p">(</span><span class="n">lelem</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="n">m</span><span class="o">.</span><span class="n">set_atypes</span><span class="p">(</span><span class="n">laty</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span> <span class="n">m</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;supercell&#39;</span><span class="p">):</span> <span class="n">m</span><span class="o">.</span><span class="n">supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">[:]</span>
        <span class="n">m</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="topo.dummy_col2vex"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.dummy_col2vex">[docs]</a>    <span class="k">def</span> <span class="nf">dummy_col2vex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lelem</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">laty</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">],</span> <span class="n">addon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns uncolored graph as molsys.mol instance</span>
<span class="sd">        if addon=&#39;spg&#39;: generate symmetry perks</span>
<span class="sd">            </span>
<span class="sd">        :Variables:</span>
<span class="sd">        - etypes(set): set of unique vertex types (as letters)</span>
<span class="sd">        - dumpensum(dict): dummy penalty summations: 1 per each vertex type</span>
<span class="sd">        - dumpenori(dict): dummy penalty orientations: None per each vertex type&quot;&quot;&quot;</span>
        <span class="c1">### APPLY CONDITIONS ***AFTER*** THE DUMMY COLORING! ###</span>
        <span class="n">etypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
        <span class="n">lenetypes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">etypes</span><span class="p">)</span>
        <span class="n">lones</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">lenetypes</span>
        <span class="n">lnones</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">lenetypes</span>
        <span class="n">dumpensum</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">etypes</span><span class="p">,</span> <span class="n">lones</span><span class="p">))</span>
        <span class="n">dumpenori</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">etypes</span><span class="p">,</span> <span class="n">lnones</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_colpen_sumrule</span><span class="p">(</span><span class="n">dumpensum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_colpen_orientrule</span><span class="p">(</span><span class="n">dumpenori</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_color_edges</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col2vex</span><span class="p">(</span><span class="n">lelem</span><span class="o">=</span><span class="n">lelem</span><span class="p">,</span> <span class="n">laty</span><span class="o">=</span><span class="n">laty</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">addon</span><span class="o">==</span><span class="s1">&#39;spg&#39;</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">addon</span><span class="p">(</span><span class="s1">&#39;spg&#39;</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">spg</span><span class="o">.</span><span class="n">generate_spgcell</span><span class="p">()</span>
            <span class="n">m</span><span class="o">.</span><span class="n">spg</span><span class="o">.</span><span class="n">generate_symmetries</span><span class="p">()</span>
            <span class="n">m</span><span class="o">.</span><span class="n">spg</span><span class="o">.</span><span class="n">generate_symperms</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">m</span></div>

<span class="c1">### COMPUTE PERMUTATIONS #######################################################</span>
<div class="viewcode-block" id="topo.compute_permutations"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.compute_permutations">[docs]</a>    <span class="k">def</span> <span class="nf">compute_permutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atypes</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atypes</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sumrule</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="c1">### HACK ###</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">),</span><span class="n">L</span><span class="p">)</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perms</span> <span class="o">=</span> <span class="n">perms</span>
        <span class="k">return</span> <span class="n">perms</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span></div>

<span class="c1">### SET CHROMOSOMES ############################################################</span>
<div class="viewcode-block" id="topo.set_chromosomes"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_chromosomes">[docs]</a>    <span class="k">def</span> <span class="nf">set_chromosomes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">allele</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bcvi</span><span class="p">)</span> <span class="k">for</span> <span class="n">bcvi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcv</span><span class="p">]</span>
        <span class="n">permchrom</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span> <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">allele</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NUMBER OF PERMUTATIONS:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">allele</span><span class="p">))</span>
        <span class="n">chromosomes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">permchrom</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span> <span class="o">=</span> <span class="n">chromosomes</span></div>

<div class="viewcode-block" id="topo.set_bcolchromosomes"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_bcolchromosomes">[docs]</a>    <span class="k">def</span> <span class="nf">set_bcolchromosomes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bcolchroms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom2bcolchrom</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span> <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcolchroms</span> <span class="o">=</span> <span class="n">bcolchroms</span></div>

<div class="viewcode-block" id="topo.chrom2bcolchrom"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.chrom2bcolchrom">[docs]</a>    <span class="k">def</span> <span class="nf">chrom2bcolchrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcv</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">chrom</span><span class="p">]</span></div>

<span class="c1">### BCOLOR SETTING FUNCTIONS ###################################################</span>
<div class="viewcode-block" id="topo.set_bcol"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_bcol">[docs]</a>    <span class="k">def</span> <span class="nf">set_bcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        utility to set color values in bcolors for bond</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            - bond : index of bond i self.blist (and colors)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span>
        <span class="c1">#logger.debug(&quot;bond from %3d to %3d : color %3d&quot; % (i, j, c) )</span>
        <span class="c1">#logger.debug(&quot;i_conn: %s&quot; % repr(self.conn[i]) )</span>
        <span class="c1">#logger.debug(&quot;j_conn: %s&quot; % repr(self.conn[j]) )</span>
        <span class="c1">### set for i</span>
        <span class="c1">### BUG FOR 2x2x2 pcu: a vertex connects twice to the same vertex!!!</span>
        <span class="c1">### TBI: add pconn for toper</span>
        <span class="n">j_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">i_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1">#logger.debug(&quot;i_ind %6d&quot; % i_ind)</span>
        <span class="c1">#logger.debug(&quot;j_ind %6d&quot; % j_ind)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.set_jbcol_from_ibcol"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_jbcol_from_ibcol">[docs]</a>    <span class="k">def</span> <span class="nf">set_jbcol_from_ibcol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">,</span> <span class="n">bcol</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        utility to set color value of j from color of i</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            - vert (int): the vertex i from which the colors of the other j</span>
<span class="sd">                vertices are assigned</span>
<span class="sd">            - bcol (list of int&#39;s): list of colors for that vertex</span>
<span class="sd">            - set_arg (bool): if True, bcolors of vertex is assigned as bcol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iconn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">iatom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iconn</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">iatom</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">iatom</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bcol</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bcol</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.set_bcol_from_perms"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_bcol_from_perms">[docs]</a>    <span class="k">def</span> <span class="nf">set_bcol_from_perms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">nconn</span><span class="p">):</span>
        <span class="n">bcol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">perms</span><span class="p">),</span><span class="n">nconn</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">perms</span><span class="p">):</span>
            <span class="n">bcol</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">bcol</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcol</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bcol</span></div>

        <span class="c1">### N.B.: works only for 0/1 coloring</span>
        <span class="c1">### TBI: any number of colors</span>
        
<span class="c1">### PENALTY FUNCTION HANDLERS ##################################################</span>
<div class="viewcode-block" id="topo.calc_colpen"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">):</span>
        <span class="c1"># print(&quot;calculating penalty for vert %d (%s)  colors: %s&quot; % (vert, self.elems[vert], str(self.bcolors[vert])))</span>
        <span class="n">pen_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen_sum</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pen_sum</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># this vertex has the correct number of colors on the edges</span>
            <span class="c1"># now compute in addition the penalty on the orientation</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen_orient</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pen_sum</span></div>

<div class="viewcode-block" id="topo.calc_colpen_from_bcolor"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen_from_bcolor">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen_from_bcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">,</span> <span class="n">bcolor</span><span class="p">):</span>
        <span class="c1"># print(&quot;calculating penalty for vert %d (%s)  colors: %s&quot; % (vert, self.elems[vert], str(bcolor)))</span>
        <span class="n">pen_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen_sum_from_bcolor</span><span class="p">(</span><span class="n">vert</span><span class="p">,</span> <span class="n">bcolor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pen_sum</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># this vertex has the correct number of colors on the edges</span>
            <span class="c1"># now compute in addition the penalty on the orientation</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen_orient_from_bcolor</span><span class="p">(</span><span class="n">vert</span><span class="p">,</span> <span class="n">bcolor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pen_sum</span></div>

<div class="viewcode-block" id="topo.calc_colpen_sum_from_bcolor"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen_sum_from_bcolor">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen_sum_from_bcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">,</span> <span class="n">bcolor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the color penalty for vertex vert</span>
<span class="sd">            rules are in list self.colpen_sumrule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get rule for first color (currently only two colors are supported for testing)</span>
        <span class="n">nc0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sumrule</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">bcolor</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pen</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="n">nc0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">colpen_sum_fact</span>
        <span class="k">return</span> <span class="n">pen</span><span class="o">*</span><span class="n">pen</span></div>

<div class="viewcode-block" id="topo.calc_colpen_sum"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen_sum">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the color penalty for vertex vert</span>
<span class="sd">            rules are in list self.colpen_sumrule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get rule for first color (currently only two colors are supported for testing)</span>
        <span class="n">nc0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sumrule</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pen</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="n">nc0</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">colpen_sum_fact</span>
        <span class="k">return</span> <span class="n">pen</span><span class="o">*</span><span class="n">pen</span></div>

<div class="viewcode-block" id="topo.set_colpen_rule"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_colpen_rule">[docs]</a>    <span class="k">def</span> <span class="nf">set_colpen_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">svert_dict</span><span class="p">,</span> <span class="n">overt_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_colpen_sumrule</span><span class="p">(</span><span class="n">svert_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_colpen_orientrule</span><span class="p">(</span><span class="n">overt_dict</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.set_colpen_sumrule"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_colpen_sumrule">[docs]</a>    <span class="k">def</span> <span class="nf">set_colpen_sumrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set the color penalty for the sum of colors</span>
<span class="sd">        :Paramteres:</span>

<span class="sd">            - vert_dict: dictionary of vertices with the number of expected edges for color 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sumrule</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colpen_sumrule</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vert_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.setup_scalprod_mats"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.setup_scalprod_mats">[docs]</a>    <span class="k">def</span> <span class="nf">setup_scalprod_mats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalmat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ji</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_neighb_coords</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ji</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vn</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">vn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scalmat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="c1">#self.scalmat = np.array(self.scalmat)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topo.calc_colpen_orient"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen_orient">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen_orient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">):</span>
        <span class="c1">### BROKEN ???</span>
        <span class="c1"># this is a HACK ... works only for vertices with two colors</span>
        <span class="c1"># if self.colpen_orientrule is None ignore</span>
        <span class="c1"># if not use the number to be added to scal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col0_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">[</span><span class="n">vert</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">col0_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">scal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalmat</span><span class="p">[</span><span class="n">vert</span><span class="p">][</span><span class="n">col0_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col0_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orient_fact</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">scal</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span><span class="p">[</span><span class="n">vert</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="topo.calc_colpen_orient_from_bcolor"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.calc_colpen_orient_from_bcolor">[docs]</a>    <span class="k">def</span> <span class="nf">calc_colpen_orient_from_bcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert</span><span class="p">,</span> <span class="n">bcolor</span><span class="p">):</span>
        <span class="c1"># this is a HACK ... works only for vertices with two colors</span>
        <span class="c1"># if self.colpen_orientrule is None ignore</span>
        <span class="c1"># if not use the number to be added to scal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span><span class="p">[</span><span class="n">vert</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col0_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bcolor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">col0_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">scal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalmat</span><span class="p">[</span><span class="n">vert</span><span class="p">][</span><span class="n">col0_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col0_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orient_fact</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">scal</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span><span class="p">[</span><span class="n">vert</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="topo.set_colpen_orientrule"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.set_colpen_orientrule">[docs]</a>    <span class="k">def</span> <span class="nf">set_colpen_orientrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vert_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set the color penalty for the orientation of colors</span>
<span class="sd">        currently this works only for color zero sum=2 (if more ... how to dadd up penalties?)</span>

<span class="sd">        :Paramteres:</span>

<span class="sd">            - vert_dict: dictionary of vertices with either None or what to add to skal</span>

<span class="sd">        example: for color 0 (sum=2) being 180deg set it to 1.0 (-1.0+1.0 = 0.0)</span>
<span class="sd">                                            90deg set it to 0.0 and the fact to -0.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">colpen_orientrule</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vert_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">return</span></div>

<span class="c1">### FILTER FUNCTIONS ###########################################################</span>
<div class="viewcode-block" id="topo.filter_vertices"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.filter_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">filter_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elems</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="n">atypes</span><span class="p">)</span> <span class="o">^</span> <span class="nb">bool</span><span class="p">(</span><span class="n">elems</span><span class="p">),</span> <span class="s2">&quot;&quot;&quot;either atom types or elements&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atypes</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">atypes</span>
        <span class="k">elif</span> <span class="n">elems</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elems</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">elems</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="n">string</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span></div>

<div class="viewcode-block" id="topo.filter_bcv"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.filter_bcv">[docs]</a>    <span class="k">def</span> <span class="nf">filter_bcv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">bcol</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;filter by color penalty threshold the allowed bond colorings</span>
<span class="sd">            per vertex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bcv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">bcvi</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcol</span><span class="p">:</span>
                <span class="n">colpen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen_from_bcolor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">bc</span><span class="p">)</span>
                <span class="c1">#print(bc, colpen)</span>
                <span class="k">if</span> <span class="n">colpen</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                    <span class="n">bcvi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
            <span class="n">bcv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcvi</span><span class="p">)</span>
        <span class="n">bcv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bcv</span><span class="p">)</span> <span class="c1">###allowed coloring per vertex</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcv</span> <span class="o">=</span> <span class="n">bcv</span>
        <span class="k">return</span> <span class="n">bcv</span></div>

<div class="viewcode-block" id="topo.filter_graph"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.filter_graph">[docs]</a>    <span class="k">def</span> <span class="nf">filter_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">bcolchroms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;filter by color penalty threshold the graphs given by bond</span>
<span class="sd">            coloring encoded by chromosomes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bcolchroms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">bcolchroms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolchroms</span>
        <span class="n">graphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ib</span><span class="p">,</span> <span class="n">ibcolchrom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bcolchroms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iv</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_jbcol_from_ibcol</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">ibcolchrom</span><span class="p">[</span><span class="n">iv</span><span class="p">],</span><span class="n">set_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">totpen</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_colpen</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">)])</span>
            <span class="c1">#print(totpen)</span>
            <span class="k">if</span> <span class="n">totpen</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">:</span>
                    <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">graphs</span></div>


<span class="c1">### AUXILIARY FUNCTIONS ########################################################</span>
<div class="viewcode-block" id="topo.bcolors2colors"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.bcolors2colors">[docs]</a>    <span class="k">def</span> <span class="nf">bcolors2colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bcolors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">iconn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">jatom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iconn</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jatom</span><span class="p">:</span>
                    <span class="n">jcol</span> <span class="o">=</span> <span class="n">bcolors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bcolors</span> <span class="o">=</span> <span class="n">bcolors</span>
        <span class="k">return</span> <span class="n">colors</span></div>

<div class="viewcode-block" id="topo.colors2bcolors"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.colors2bcolors">[docs]</a>    <span class="k">def</span> <span class="nf">colors2bcolors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">bcolors</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">conni</span><span class="p">)</span> <span class="k">for</span> <span class="n">conni</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blist</span><span class="p">):</span>
            <span class="n">conni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">connj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">bcolors</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">conni</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">bcolors</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">connj</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="k">return</span> <span class="n">bcolors</span></div>

<div class="viewcode-block" id="topo.colors2proportions"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.colors2proportions">[docs]</a>    <span class="k">def</span> <span class="nf">colors2proportions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1">###set colors by argument, get proportions via color</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">),</span> <span class="s2">&quot;number of colors is different than number of bonds&quot;</span>
        <span class="n">prop</span><span class="p">,</span> <span class="n">nprop</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span> <span class="o">*</span><span class="n">Counter</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">most_common</span><span class="p">()</span> <span class="p">)</span> <span class="c1">###already sorted</span>
        <span class="c1">###TBI: working for nprop[-1]!=1</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="k">return</span> <span class="n">prop</span><span class="p">,</span> <span class="n">nprop</span></div>

<div class="viewcode-block" id="topo.proportions2colors"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.proportions2colors">[docs]</a>    <span class="k">def</span> <span class="nf">proportions2colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">set_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nprop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span><span class="o">%</span><span class="n">nprop</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span>  <span class="s2">&quot;these proportions do not work&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbonds</span><span class="o">/</span><span class="n">nprop</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">nc</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">set_arg</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nprop</span> <span class="o">=</span> <span class="n">prop</span><span class="p">,</span> <span class="n">nprop</span>
        <span class="k">return</span> <span class="n">colors</span></div>

<div class="viewcode-block" id="topo.GCD"><a class="viewcode-back" href="../../_api/molsys.html#molsys.topo.topo.GCD">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">GCD</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="o">*</span><span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute greatest common divisor for a list.</span>
<span class="sd">        rationale: fractions.gcd works only for two numbers&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;__iter__&#39;</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">GCD</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Roberto Amabile, Johannes P. Duerholt, Julian Keupp, Rochus Schmid

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>