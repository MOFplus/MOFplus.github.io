

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>molsys.util.toper &mdash; molsys 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> molsys
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_addon.html">1. Addons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_util.html">2. Utility Modules</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Stuff</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tech_api.html">1. API Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">File Formats</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../file_io.html">1. File I/O</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">molsys</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>molsys.util.toper</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for molsys.util.toper</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">molsys</span>
<span class="kn">from</span> <span class="nn">graph_tool</span> <span class="k">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">GraphView</span>
<span class="kn">from</span> <span class="nn">graph_tool.topology</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">mofplus</span> <span class="k">import</span> <span class="n">user_api</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">ascii_lowercase</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">molsys.util.color</span> <span class="k">import</span> <span class="n">make_mol</span><span class="p">,</span> <span class="n">vcolor2elem</span>
<span class="kn">from</span> <span class="nn">molsys.util.sysmisc</span> <span class="k">import</span> <span class="n">_makedirs</span><span class="p">,</span> <span class="n">_checkrundir</span>
<span class="kn">from</span> <span class="nn">molsys.util.misc</span> <span class="k">import</span> <span class="n">argsorted</span><span class="p">,</span> <span class="n">triplenats_on_sphere</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;molsys.toper&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="conngraph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph">[docs]</a><span class="k">class</span> <span class="nc">conngraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; This is the &quot;conngraph&quot; class</span>
<span class="sd">    It is the basis of the molgraph and topograph classes, which use graph theory for the deconstruction of</span>
<span class="sd">    MOF structures, or the analysis of topologies, respectively. It provides the important ground functions</span>
<span class="sd">    used by both classes, like make_graph, flood_fill and center.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - mol: molsys.mol or molsys.topo object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">periodic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">use_pconn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span>
            <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span>
            <span class="n">subgraph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

<div class="viewcode-block" id="conngraph.split"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Argument:</span>
<span class="sd">        - other(conngraph=None): other conngraph (as subgraph) used as graph</span>
<span class="sd">            separator. If other is None: a standard component split is performed</span>

<span class="sd">        :Return:</span>
<span class="sd">        - cgs(list of conngraphs): splitted conngraphs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### split graph ###</span>
        <span class="n">gws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_graph</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1">### remove duplicates ###</span>
        <span class="c1"># N.B.: graphs must be pruned according to graph view</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">duplicates</span><span class="p">:</span>
            <span class="n">ugws</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">gw</span> <span class="ow">in</span> <span class="n">gws</span><span class="p">:</span>
                <span class="n">p_gw</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">gw</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">ugw</span> <span class="ow">in</span> <span class="n">ugws</span><span class="p">:</span>
                    <span class="n">p_ugw</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">ugw</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">iso</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">p_gw</span><span class="p">,</span> <span class="n">p_ugw</span><span class="p">,</span>
                        <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">p_gw</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">p_ugw</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span> <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">iso</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                    <span class="n">ugws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gw</span><span class="p">)</span>
            <span class="n">gws</span> <span class="o">=</span> <span class="n">ugws</span>
        <span class="c1">### extract molecules ###</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gw</span> <span class="ow">in</span> <span class="n">gws</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_mol_by_subgraph</span><span class="p">(</span><span class="n">gw</span><span class="p">)</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="c1">### split to new conngraphs ###</span>
        <span class="n">cgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span>
            <span class="n">cg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">cgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cgs</span></div>

<div class="viewcode-block" id="conngraph.split_graph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.split_graph">[docs]</a>    <span class="k">def</span> <span class="nf">split_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Caveat:</span>
<span class="sd">        - only regioisomerism detected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">umolg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vfilt</span><span class="p">,</span> <span class="n">vubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraphs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">umolg</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">vfilt</span><span class="p">)</span>
        <span class="c1"># filtered graph is splitted into components</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">histograms</span> <span class="o">=</span> <span class="n">label_components</span><span class="p">(</span><span class="n">umolg</span><span class="p">)</span>
        <span class="c1"># -1 as separator and 0 as first component (only when other is not None)</span>
        <span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">gws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># if filtered (only when other is not None)</span>
                <span class="k">continue</span>
            <span class="n">gw</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">umolg</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">gws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gws</span></div>

<div class="viewcode-block" id="conngraph.label_subgraphs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label graph with subgraph/s</span>
<span class="sd">        N.B.: if cg is iterable, then order of index is order of priority</span>
<span class="sd">        Example:</span>
<span class="sd">            if paddlewheel comes before the carboxylate, then</span>
<span class="sd">            paddlewheels and carboxylates out of the paddlewheels are found.</span>
<span class="sd">            if carboxylate comes before the paddlewheel, then</span>
<span class="sd">            carboxylates (also in paddlewheels) are found and not paddlewheels.</span>

<span class="sd">        :Return:</span>
<span class="sd">            vfilt (vprop): 1 where (collective) match, 0 else</span>
<span class="sd">            vsubs (vprop): index where match for ordered subgraph, -1 else</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cg</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">vsubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;int64_t&#39;</span><span class="p">)</span>
        <span class="n">vsubs</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># default: no match found, not visited by subgraphs</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># to prevent further visiting of the subgraph isomorphism</span>
        <span class="c1"># multiple case #</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">icg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cg</span><span class="p">):</span>
                <span class="n">ivfilt</span><span class="p">,</span> <span class="n">ivsubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraphs</span><span class="p">(</span><span class="n">icg</span><span class="p">)</span>
                <span class="n">vsubs</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ivfilt</span><span class="o">.</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">ivsubs</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ivfilt</span><span class="o">.</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># found</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">vsubs</span><span class="o">.</span><span class="n">a</span><span class="o">!=-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">vfilt</span><span class="p">,</span> <span class="n">vsubs</span>
        <span class="c1"># single case #</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># infinite while until no subgraph is isomorphic</span>
            <span class="c1"># cg.molg serves as separator as in str.split</span>
            <span class="n">umolg</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">vfilt</span><span class="p">)</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">umolg</span><span class="p">,</span>
                <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span> <span class="n">subgraph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subs</span><span class="p">:</span>
                <span class="c1"># a match is found and filtered</span>
                <span class="n">sub</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">sub</span><span class="o">.</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">vsubs</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">sub</span><span class="o">.</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span>
                <span class="n">cs</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># last match it filtered</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">vfilt</span><span class="p">,</span> <span class="n">vsubs</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_neighbours"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_neighbours">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsubs</span><span class="p">):</span>
        <span class="n">nsubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s1">&#39;int64_t&#39;</span><span class="p">)</span>
        <span class="n">nsubs</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="c1"># -2 -&gt; not connector; -1 -&gt; connector of unknown subgraph</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="n">vsub</span> <span class="o">=</span> <span class="n">vsubs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
                <span class="n">nsub</span> <span class="o">=</span> <span class="n">vsubs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nsub</span> <span class="o">!=</span> <span class="n">vsub</span><span class="p">:</span> <span class="c1"># then v is a connector!</span>
                    <span class="n">nsubs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsub</span>
        <span class="k">return</span> <span class="n">nsubs</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_edges"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_edges">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsubs</span><span class="p">):</span>
        <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">efilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">esubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;vector&lt;int64_t&gt;&quot;</span><span class="p">)</span>
        <span class="n">ekinds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">vsource</span> <span class="o">=</span> <span class="n">vsubs</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()]</span>
            <span class="n">vtarget</span> <span class="o">=</span> <span class="n">vsubs</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">vsource</span> <span class="o">&gt;</span> <span class="n">vtarget</span><span class="p">:</span>
                <span class="n">vtarget</span><span class="p">,</span> <span class="n">vsource</span> <span class="o">=</span> <span class="n">vsource</span><span class="p">,</span> <span class="n">vtarget</span>
            <span class="n">ekind</span> <span class="o">=</span> <span class="p">(</span><span class="n">vsource</span><span class="p">,</span> <span class="n">vtarget</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vsource</span> <span class="o">!=</span> <span class="n">vtarget</span><span class="p">:</span>
                <span class="n">ekinds</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">((</span><span class="n">ekind</span><span class="p">,))</span>
                <span class="n">efilt</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">esubs</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">ekind</span>
        <span class="k">return</span> <span class="n">efilt</span><span class="p">,</span> <span class="n">esubs</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_components"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_components">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">molgw</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="n">efilt</span><span class="p">)</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">histogram</span> <span class="o">=</span> <span class="n">label_components</span><span class="p">(</span><span class="n">molgw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">components</span><span class="p">,</span> <span class="n">histogram</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_elementsequences"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_elementsequences">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_elementsequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsubs</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
        <span class="n">elemseqs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nsubs</span><span class="o">.</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="c1">#else: it is a connector</span>
                <span class="k">continue</span>
            <span class="c1"># apply only on subgraph</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">components</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">molgw</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">vfilt</span><span class="p">)</span>
            <span class="c1"># distances from connector to the subgraph</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">shortest_distance</span><span class="p">(</span><span class="n">molgw</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">dists</span><span class="o">.</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># filtered out</span>
            <span class="n">dists</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># source</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># where considered</span>
            <span class="n">idists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">ielems</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="c1"># element sequence</span>
            <span class="n">distelems</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idists</span><span class="p">,</span> <span class="n">ielems</span><span class="p">)</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">distelems</span><span class="p">)</span>
            <span class="n">udistelems</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
            <span class="n">udistseq</span> <span class="o">=</span> <span class="p">[</span><span class="n">ui</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ui</span> <span class="ow">in</span> <span class="n">udistelems</span><span class="p">]</span>
            <span class="n">distcounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">udistseq</span><span class="p">)</span>
            <span class="c1"># string sequence</span>
            <span class="n">lfmt</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">distcounter</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ue</span> <span class="ow">in</span> <span class="n">udistelems</span><span class="p">:</span>
                <span class="n">lfmt</span><span class="p">[</span><span class="n">ue</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">counter</span><span class="p">[</span><span class="n">ue</span><span class="p">])</span>
            <span class="n">elemseq</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lfmt</span><span class="p">)</span>
            <span class="n">elemseqs</span><span class="p">[</span><span class="n">elemseq</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">elemseqs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">elemseqs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elemseqs</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_connectors"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_connectors">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_connectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vsubs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># label inter-subgraph edges</span>
        <span class="n">efilt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_edges</span><span class="p">(</span><span class="n">vsubs</span><span class="p">)</span>
        <span class="c1"># cut inter-subgraph edges</span>
        <span class="n">components</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_components</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span>
        <span class="c1"># neighbour subgraphs</span>
        <span class="n">nsubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_neighbours</span><span class="p">(</span><span class="n">vsubs</span><span class="p">)</span>
        <span class="c1"># make string sequence of elements per each connector</span>
        <span class="n">elemseqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_elementsequences</span><span class="p">(</span><span class="n">nsubs</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nsubs</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">elemseqs</span></div>

<div class="viewcode-block" id="conngraph.label_subgraph_blocks"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.label_subgraph_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">label_subgraph_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">elemseqs</span><span class="p">):</span>
        <span class="c1">### TO-DO: Distinguish by connectors (regiochemistry, topological)</span>
        <span class="c1">### TO-DO: Distinguish by coordinates (stereochemistry, geometric)</span>
        <span class="n">molg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># to change molg.vp.elem</span>
        <span class="k">for</span> <span class="n">eseq</span> <span class="ow">in</span> <span class="n">elemseqs</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">elemseqs</span><span class="p">[</span><span class="n">eseq</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eseq</span>
        <span class="n">cvfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">cvfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">svfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">svfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">sblocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">a</span><span class="p">):</span>
            <span class="n">cvfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">uc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">cvfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="n">uc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">molgw</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">molg</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">cvfilt</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># first block not found by construction, so add to kind of blocks</span>
            <span class="k">for</span> <span class="n">ksbb</span> <span class="ow">in</span> <span class="n">sblocks</span><span class="p">:</span>
                <span class="n">p_ksbb</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">ksbb</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">p_molgw</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">molgw</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">p_ksbb</span><span class="p">,</span> <span class="n">p_molgw</span><span class="p">,</span>
                    <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">p_ksbb</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">p_molgw</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span> <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">svfilt</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">components</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">uc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sblocks</span><span class="p">)</span> <span class="c1"># starts from zero</span>
                <span class="n">sblocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">molgw</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="c1"># copy is needed otherwise view is the same</span>
        <span class="k">return</span> <span class="n">sblocks</span><span class="p">,</span> <span class="n">svfilt</span></div>

<div class="viewcode-block" id="conngraph.extract_mol_by_subgraph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.extract_mol_by_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">extract_mol_by_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract mol object out of connectivity graph</span>

<span class="sd">        :Parameters:</span>
<span class="sd">        cg(conngraph): connectivity graph or graph view</span>

<span class="sd">        :Return:</span>
<span class="sd">        m(mol): molecular object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cg</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">new_mol_by_index</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="conngraph.make_block_by_subgraph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.make_block_by_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">make_block_by_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgraph</span><span class="p">,</span> <span class="n">elemseqs</span><span class="p">):</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_mol_by_subgraph</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">addon</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">)</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">is_bb</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># connector type</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">subgraph</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subgraph</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
        <span class="n">bbc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bbca</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bbct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elems</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elemseqs</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bbc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">bbca</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="n">bbct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">ct</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">bb</span><span class="o">.</span><span class="n">sort_connectors_type</span><span class="p">(</span><span class="n">bbct</span><span class="p">)</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">connectors_type</span> <span class="o">=</span> <span class="n">ct</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">connectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ca</span><span class="p">]</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">connector_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">bbca</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ca</span><span class="p">]</span>
        <span class="n">bb</span><span class="o">.</span><span class="n">center_point</span> <span class="o">=</span> <span class="s1">&#39;coc&#39;</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">unwrap_box</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bb</span></div>

<div class="viewcode-block" id="conngraph.extract_blocks"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.extract_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">extract_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cgs</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="s2">&quot;bbs&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">vsubs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraphs</span><span class="p">(</span><span class="n">cgs</span><span class="p">)</span>
        <span class="n">nsubs</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">elemseqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_connectors</span><span class="p">(</span><span class="n">vsubs</span><span class="p">)</span>
        <span class="n">subblocks</span><span class="p">,</span> <span class="n">subvfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_subgraph_blocks</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">elemseqs</span><span class="p">)</span>
        <span class="n">bbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_makedirs</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subblocks</span><span class="p">):</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_block_by_subgraph</span><span class="p">(</span><span class="n">subb</span><span class="p">,</span> <span class="n">elemseqs</span><span class="p">)</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%%</span><span class="s2">s/</span><span class="si">%%%d</span><span class="s2">d.mfpx&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subblocks</span><span class="p">))))</span> <span class="o">%</span> <span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="n">bbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bbs</span></div>

<div class="viewcode-block" id="conngraph.make_graph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.make_graph">[docs]</a>    <span class="k">def</span> <span class="nf">make_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; Create a Graph object from a molsys.mol object. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># setup vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">fix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">atype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;vector&lt;double&gt;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="c1"># boolean for flood fill</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="n">ig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">atype</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">ig</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forbidden</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">fix</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">fix</span><span class="p">[</span><span class="n">ig</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># setup edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># create Backup of the original graph for comparison</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="conngraph.make_graph_from_morphism"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.make_graph_from_morphism">[docs]</a>    <span class="k">def</span> <span class="nf">make_graph_from_morphism</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;make graph from morphism applied to current graph</span>
<span class="sd">        iold,jold TO BE CHECKED&quot;&quot;&quot;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">morpha</span> <span class="o">=</span> <span class="n">morph</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">morpha</span><span class="p">]</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">)[</span><span class="n">morpha</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">atypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">)[</span><span class="n">morpha</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">pconn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">set_empty_conn</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">set_empty_pconn</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iold</span><span class="p">,</span><span class="n">jold</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">ctab</span><span class="p">:</span>
            <span class="c1"># apply morphism to indices</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">morpha</span><span class="p">[</span><span class="n">iold</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">morpha</span><span class="p">[</span><span class="n">jold</span><span class="p">]</span>
            <span class="c1"># get ijth position of j in ith conn</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># pop index corresponding to j from ith conn (and check)</span>
            <span class="k">assert</span> <span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span> <span class="o">==</span> <span class="n">j</span>
            <span class="c1"># append index to new ith conn</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># pop image corresponding to j from ith pconn</span>
            <span class="n">jp</span> <span class="o">=</span> <span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span>
            <span class="c1"># append image to new ith pconn</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jp</span><span class="p">)</span>
            <span class="c1"># same story here with switched indices i,j&lt;-j,i</span>
            <span class="n">ji</span> <span class="o">=</span> <span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ji</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="n">pconn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ji</span><span class="p">)</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">set_ctab_from_conn</span><span class="p">(</span><span class="n">pconn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_etab_from_tabs</span><span class="p">()</span>
        <span class="n">cg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="c1"># new conngraph</span>
        <span class="k">return</span> <span class="n">cg</span></div>
    
<div class="viewcode-block" id="conngraph.cut_to_2core"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.cut_to_2core">[docs]</a>    <span class="k">def</span> <span class="nf">cut_to_2core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cuts graph to its 2-core</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kcore_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">)</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">idxlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">fix</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idxlist</span></div>

<div class="viewcode-block" id="conngraph.remove_2conns"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.remove_2conns">[docs]</a>    <span class="k">def</span> <span class="nf">remove_2conns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From self.molg, removes all vertices with 2 connecting edges.</span>
<span class="sd">        </span>
<span class="sd">        Returns: boolean if the method could find any 2-connected vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found_2conns</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">fix</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">():</span> <span class="n">neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">found_2conns</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">neighbours</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">neighbours</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_2conns</span><span class="p">()</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">found_2conns</span></div>
    
<div class="viewcode-block" id="conngraph.handle_islands"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.handle_islands">[docs]</a>    <span class="k">def</span> <span class="nf">handle_islands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh_small</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles parts of the structure which are not connected to the rest (&quot;islands&quot;).</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - thresh_small: If the island is smaller than the size of the largest island multiplied by</span>
<span class="sd">          thresh_small, it will be deleted.</span>
<span class="sd">        - silent: if True, a warning will be printed out when there are multiple large islands.</span>
<span class="sd">        </span>
<span class="sd">        :Returns:</span>
<span class="sd">        - n_removed_atoms: Number of removed atoms</span>
<span class="sd">        - multiple_large_islands: boolean if there are multiple large islands</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">multiple_large_islands</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">islands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_islands</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">islands</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># we only have 1 island, so nothing has to be done</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ok we have multiple islands, time to find out what we have here.</span>
            <span class="c1"># first we sort the islands by size</span>
            <span class="n">island_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">islands</span><span class="p">))</span>
            <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">island_sizes</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
            <span class="n">biggest_size</span> <span class="o">=</span> <span class="n">island_sizes</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">remove_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># then we compare the sizes of the smaller islands with the size of the largest island</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">island_sizes</span><span class="p">):</span>
                <span class="c1"># don&#39;t compare the biggest island with itself though...</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">sort_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">biggest_size</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="n">thresh_small</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">islands</span><span class="p">[</span><span class="n">index</span><span class="p">])):</span>
                            <span class="n">remove_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">multiple_large_islands</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> 
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Two large parts of the structure are not connected to each other. Check the structure.&quot;</span><span class="p">)</span>
            <span class="c1"># DELETE THE SMALL ISLANDS LIKE GLOBAL WARMING !!!!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">remove_list</span><span class="p">)</span>
            <span class="n">n_removed_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">remove_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n_removed_atoms</span><span class="p">,</span> <span class="n">multiple_large_islands</span></div>
    
<div class="viewcode-block" id="conngraph.get_islands"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.get_islands">[docs]</a>    <span class="k">def</span> <span class="nf">get_islands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Finds all islands. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">remain_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()))</span>
        <span class="n">islands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">remain_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">remain_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">[])</span>
            <span class="c1">#print(len(l) # debug message - prints sizes of all islands...)</span>
            <span class="n">islands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">remain_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">islands</span></div>
        
<div class="viewcode-block" id="conngraph.flood_fill"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.flood_fill">[docs]</a>    <span class="k">def</span> <span class="nf">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">return_list</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses flood fill to find all vertices that are connected to the starting vertex.</span>
<span class="sd">        Caution: You might want to reset the vertex property &quot;filled&quot; before calling flood_fill!</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - vertex: starting vertex</span>
<span class="sd">        - return_list: list of vertices which have already been iterated (when calling the function, you might have to force this to be [])</span>
<span class="sd">        - graph: The graph in which flood fill should be performed</span>
<span class="sd">        </span>
<span class="sd">        :Returns:</span>
<span class="sd">        - list of all vertices that could be reached by flood fill.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># perform flood fill</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">return_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_list</span></div>

<div class="viewcode-block" id="conngraph.get_automorphisms"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.get_automorphisms">[docs]</a>    <span class="k">def</span> <span class="nf">get_automorphisms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain all automorphisms of conngraph graph</span>
<span class="sd">        An automorphism is an isomorphism of the graph with itself.</span>
<span class="sd">        WARNING: the procedure may be slow, especially for uncolored nets.</span>

<span class="sd">        &gt;&gt;&gt; autos_default = tt.tg.get_automorphisms()</span>
<span class="sd">        &gt;&gt;&gt; autos_nocolor = tt.tg.get_automorphisms(color=False)</span>
<span class="sd">        &gt;&gt;&gt; autos_justone = tt.tg.get_automorphisms(color=False, max_n=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">molg</span><span class="p">,</span> <span class="n">molg</span><span class="p">,</span>
                <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span>
                <span class="n">edge_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">),</span>
                <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">molg</span><span class="p">,</span> <span class="n">molg</span><span class="p">,</span>
                <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span>
                <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="conngraph.is_isomorphic"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.is_isomorphic">[docs]</a>    <span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the instance graph is isomorphic to a target graph.</span>
<span class="sd">        Check the existence of at least an isomorphism between the</span>
<span class="sd">        instance conngraph graph and another conngraph graph.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tt.tg.is_isomorphic(tt.tg) # trivial</span>
<span class="sd">        True</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tt.tg.is_isomorphic(tt.mg) # trivial (most of the time)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molg1</span><span class="p">,</span> <span class="n">molg2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">molg</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">molg1</span><span class="o">.</span><span class="n">ep</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">molg2</span><span class="o">.</span><span class="n">ep</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">isom</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">molg1</span><span class="p">,</span> <span class="n">molg2</span><span class="p">,</span>
                    <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg1</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">molg2</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span>
                    <span class="n">edge_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg1</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">molg2</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">),</span>
                    <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">isom</span><span class="p">)</span> <span class="c1"># is there any isomorphism? True/False</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># gentle: not isomorphic w/o colors</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># something went wrong and unexpected</span>
                    <span class="kn">import</span> <span class="nn">traceback</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># is there at least one (=any) isomorphism? True/False</span>
            <span class="c1">#   isom is a list of zero or one element, and its boolean</span>
            <span class="c1">#   value is True whether it is not empty</span>
            <span class="n">isom</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">molg1</span><span class="p">,</span> <span class="n">molg2</span><span class="p">,</span>
                <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">molg1</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">molg2</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span>
                <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># N.B.: the following method</span>
            <span class="c1">#   `isomorphism(molg1, molg2, **kwargs)`</span>
            <span class="c1"># is NOT enough for taking vertex/edge labelling into account</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">isom</span><span class="p">)</span></div>

<div class="viewcode-block" id="conngraph.print_isomorphism"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.conngraph.print_isomorphism">[docs]</a>    <span class="k">def</span> <span class="nf">print_isomorphism</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iso</span><span class="p">,</span> <span class="n">vertex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print isomorphism as map of indices&quot;&quot;&quot;</span>
        <span class="c1">### TBI: separate RETURN from PRINT! (that&#39;s needed for ACAB)</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">molg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span>
        <span class="k">if</span> <span class="n">vertex</span><span class="p">:</span>
            <span class="n">vs_</span> <span class="o">=</span> <span class="p">[</span><span class="n">iso</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
            <span class="n">vfd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vs_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">vs_f</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%%%d</span><span class="s2">d&quot;</span> <span class="o">%</span> <span class="n">vfd</span> <span class="o">%</span> <span class="n">v_</span> <span class="k">for</span> <span class="n">v_</span> <span class="ow">in</span> <span class="n">vs_</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;V:&quot;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vs_f</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">:</span>
            <span class="c1"># TBI?: there should be a faster, more graph_tool-like way</span>
            <span class="n">es_</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">s</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
                <span class="n">s_</span><span class="p">,</span> <span class="n">t_</span> <span class="o">=</span> <span class="n">iso</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">iso</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">i_</span> <span class="o">=</span> <span class="n">molg</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="n">s_</span><span class="p">,</span><span class="n">t_</span><span class="p">]</span>
                <span class="n">es_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_</span><span class="p">)</span>
            <span class="n">efd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">es_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">es_f</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%%%d</span><span class="s2">d&quot;</span> <span class="o">%</span> <span class="n">efd</span> <span class="o">%</span> <span class="n">e_</span> <span class="k">for</span> <span class="n">e_</span> <span class="ow">in</span> <span class="n">es_</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;E:&quot;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">es_f</span><span class="p">))</span>
        <span class="k">return</span></div></div>
    
<div class="viewcode-block" id="molgraph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph">[docs]</a><span class="k">class</span> <span class="nc">molgraph</span><span class="p">(</span><span class="n">conngraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class handles the deconstruction of a MOF structure into a graph. &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="molgraph.determine_Nk"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.determine_Nk">[docs]</a>    <span class="k">def</span> <span class="nf">determine_Nk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Assigns size of minimal ring to every edge &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">shortest_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">(),</span> <span class="n">target</span><span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">2147483647</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#print(self.molg.ep.Nk[e])</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="molgraph.find_cluster_threshold"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.find_cluster_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">find_cluster_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds thresholds.</span>
<span class="sd">        Needs Nk values of the edges -&gt; determine_Nk() has to be called before calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">Nk</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Nk</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Nk</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Nk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nk</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span></div>

<div class="viewcode-block" id="molgraph.get_clusters"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.get_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_side_chains</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the clusters of the MOF.</span>
<span class="sd">        </span>
<span class="sd">        The clusters (saved in self.clusters) are lists of atoms, which belong in one group or form </span>
<span class="sd">        one &#39;building block&#39;. They are firstly defined by ring sizes: If the Nk value is higher or equal </span>
<span class="sd">        than the threshold, this bond will be defined as an inter-cluster bond.</span>
<span class="sd">        The clusters can be later modified to create different representations of the framework, for </span>
<span class="sd">        example by summarizing all organic clusters which are bonded to each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_cluster_threshold</span><span class="p">()</span>
        <span class="c1"># remove side chains (unnecessary at the moment)</span>
        <span class="k">if</span> <span class="n">remove_side_chains</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">forloop</span><span class="p">():</span>
                <span class="n">broken</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="c1"># since the indices of the edges will change when one edge is removed, the for loop has to be</span>
                    <span class="c1"># restarted every time an edge is deleted, or else there will be problems when the next edge </span>
                    <span class="c1"># should be deleted...</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># found a sidechain... now use flood_fill to find out which side of the</span>
                        <span class="c1"># edge belongs to the sidechain and which to the main framework</span>
                        <span class="n">src</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>
                        <span class="n">trg</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">struc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="n">struc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">trg</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="c1"># the larger structure is the framework</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">struc1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">struc2</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">struc1</span><span class="p">)):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">struc2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">struc1</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">struc2</span><span class="p">)):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># both structures have same size</span>
                            <span class="k">pass</span>
                        <span class="n">broken</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">return</span> <span class="n">broken</span>
            <span class="k">while</span> <span class="n">forloop</span><span class="p">():</span>
                <span class="k">pass</span>
        <span class="c1">### set edge filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">thresh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">Nk</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">)</span>
        <span class="c1">### perform flood fill</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">False</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">get_array</span><span class="p">()):</span>
            <span class="n">vidx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">get_array</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vidx</span><span class="p">)</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vstart</span><span class="p">),</span> <span class="p">[])</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">cluster</span><span class="p">))</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">clear_filters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span>
        <span class="k">return</span> <span class="n">clusters</span></div>

<div class="viewcode-block" id="molgraph.get_unique_clusters"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.get_unique_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get unique clusters</span>
<span class="sd">        return their cluster types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Get unique building blocks which are distinct by connectivity&quot;</span><span class="p">)</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">new_mol_by_index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>
        <span class="n">mgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">molgraph</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
        <span class="n">molgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mg</span><span class="o">.</span><span class="n">molg</span> <span class="k">for</span> <span class="n">mg</span> <span class="ow">in</span> <span class="n">mgs</span><span class="p">]</span>
        <span class="n">unique_ms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">type_ms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">molgi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molgs</span><span class="p">):</span>
            <span class="n">new</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">unique_ms</span><span class="p">:</span>
                <span class="n">molgj</span> <span class="o">=</span> <span class="n">molgs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">iso</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">molgi</span><span class="p">,</span> <span class="n">molgj</span><span class="p">,</span> <span class="n">vertex_label</span><span class="o">=</span><span class="p">(</span><span class="n">molgi</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">,</span> <span class="n">molgj</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">elem</span><span class="p">),</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iso</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">type_ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ms</span><span class="p">))</span>
                <span class="n">unique_ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">type_ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_ms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">type_ms</span></div>
    
<div class="viewcode-block" id="molgraph.get_cluster_atoms"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.get_cluster_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all atoms in the clusters of the conngraph.</span>
<span class="sd">        Needs clusters in self.clusters -&gt; call get_clusters before calling this method!</span>
<span class="sd">        </span>
<span class="sd">        :Returns: </span>
<span class="sd">        -List of list of vertices of each cluster in the backup &quot;self.keep&quot; graph.</span>
<span class="sd">        -List of list of atom ids of each cluster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>
        <span class="n">midx_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># set edge filter</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">cluster_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                <span class="n">via</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">via</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                        <span class="c1"># found external bond, set edge filter here</span>
                        <span class="n">midx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">via</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">atomid</span> <span class="o">=</span> <span class="p">(</span><span class="n">midx_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">midx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">midx_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">midx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">keepedge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">atomid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atomid</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">[</span><span class="n">keepedge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">act</span><span class="p">)</span>
        <span class="c1"># then find all connecting atoms</span>
        <span class="n">clusters_vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">clusters_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vid</span><span class="p">)</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">atomid</span> <span class="o">=</span> <span class="n">midx_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">midx</span><span class="p">)</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">atomid</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">this_cluster_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flood_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="p">[])</span>
                    <span class="n">clusters_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_cluster_verts</span><span class="p">)</span>
                    <span class="n">this_cluster_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">this_cluster_verts</span><span class="p">:</span>
                        <span class="n">this_cluster_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="c1"># set atomtypes in self.mol</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ic</span>
                    <span class="n">clusters_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_cluster_atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span><span class="o">.</span><span class="n">clear_filters</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clusters_vertices</span><span class="p">,</span> <span class="n">clusters_atoms</span></div>
    
<div class="viewcode-block" id="molgraph.cluster_conn"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.cluster_conn">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that returns a list, which describes, which clusters are connected with each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="n">cluster_conn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">this_cluster_conn</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ext_bond</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                <span class="n">via</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">via</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                        <span class="n">ext_bond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
            <span class="c1">#print(&quot;cluster %s consisting of %d atoms is %d times connected&quot; % (str(i), len(cluster_atoms), len(ext_bond)))</span>
            <span class="c1"># now check to which clusters these external bonds belong to</span>
            <span class="k">for</span> <span class="n">ea</span> <span class="ow">in</span> <span class="n">ext_bond</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ji</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ea</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">this_cluster_conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ji</span><span class="p">)</span>
            <span class="c1">#            print(&quot; -&gt; bonded to cluster &quot;, ji)</span>
                        <span class="k">break</span>
            <span class="n">cluster_conn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_cluster_conn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cluster_conn</span></div>
    
<div class="viewcode-block" id="molgraph.get_bbs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.get_bbs">[docs]</a>    <span class="k">def</span> <span class="nf">get_bbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the building blocks (BBs) of the MOF.</span>
<span class="sd">        Since the definition of &quot;building block&quot; is arbitrary, this function will do the following things:</span>
<span class="sd">        - if multiple 2-connected clusters are connected to each other, these clusters will be summarized</span>
<span class="sd">          as one BB.</span>
<span class="sd">        The function will OVERWRITE self.clusters and replace it with the newly generated building blocks!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>
        <span class="c1"># summarize 2-connected clusters:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># find external bonds</span>
            <span class="n">cluster_conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_conn</span><span class="p">()</span>
            <span class="c1"># find out if 2-connected clusters are bonded to other 2-connected clusters</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_conn</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_conn</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># and if they are, create new clusters which contain everything the first clusters contained</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                            <span class="c1"># and then remove those clusters</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
                                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span></div>
    
<div class="viewcode-block" id="molgraph.detect_organicity"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.detect_organicity">[docs]</a>    <span class="k">def</span> <span class="nf">detect_organicity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">organic_elements</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;si&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;cl&quot;</span><span class="p">,</span> <span class="s2">&quot;as&quot;</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">,</span> <span class="s2">&quot;br&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds out whether a cluster classifies as &quot;organic&quot; or &quot;inorganic&quot;.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - organic_elements: This is a list which defines, which elements are allowed inside</span>
<span class="sd">          an &quot;organic&quot; building block. All element symbols must be lower case. Default:</span>
<span class="sd">          H, B, C, N, O, F, Si, P, S, Cl, As, Se, Br, I</span>
<span class="sd">          </span>
<span class="sd">        :Returns:</span>
<span class="sd">        - self.cluster_organicity: list, each element is True (for organic) or False (for </span>
<span class="sd">          inorganic), and the index is equivalent to the index of the cluster in self.clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>        
        <span class="c1"># go through each atom in every cluster and compare the elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_organicity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">:</span>
            <span class="n">org</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">midx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">midx</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">organic_elements</span><span class="p">:</span>
                    <span class="n">org</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_organicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_organicity</span></div>
    
<div class="viewcode-block" id="molgraph.get_bbs_by_organicity"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.get_bbs_by_organicity">[docs]</a>    <span class="k">def</span> <span class="nf">get_bbs_by_organicity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Groups all organic clusters, which are connected with each other, into a single cluster.</span>
<span class="sd">        Like self.get_bbs, this method will OVERWRITE self.clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Collapse clusters in grouped superclusters&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;cluster_organicity&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">detect_organicity</span><span class="p">()</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># find external bonds</span>
            <span class="n">cluster_conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_conn</span><span class="p">()</span>
            <span class="c1"># find out if organic clusters are bonded to other organic clusters</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cluster_conn</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_organicity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_organicity</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="c1"># and if they are, create new clusters which contain everything the first clusters contained</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                            <span class="c1"># and then remove those clusters</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
                                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">stop</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="c1"># recompute organicity, because of the changed indices</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">detect_organicity</span><span class="p">()</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span></div>

<div class="viewcode-block" id="molgraph.make_topograph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.molgraph.make_topograph">[docs]</a>    <span class="k">def</span> <span class="nf">make_topograph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_2conns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color_clusters</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the topograph of the topology of the MOF.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - verbose: if True, there will be some information printed out</span>
<span class="sd">        - allow_2conns: if True, 2-connected vertices will be allowed in the topograph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;only one cluster is found!&quot;</span><span class="p">)</span>
            <span class="n">tm</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">color_clusters</span><span class="p">:</span>
                <span class="n">type_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_clusters</span><span class="p">()</span>
                <span class="n">tm</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">vcolor2elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_clusters</span><span class="p">]</span>
            <span class="n">tg</span> <span class="o">=</span> <span class="n">topograph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">allow_2conns</span><span class="p">)</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshes</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">tg</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">molsys</span><span class="o">.</span><span class="n">mol</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">force_topo</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_empty_conn</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">ext_bond</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cidx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                <span class="n">cidx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">midx</span><span class="p">[</span><span class="n">ia</span><span class="p">])</span>
                <span class="n">via</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">via</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_atoms</span><span class="p">:</span>
                        <span class="c1"># thus bond is an external bond</span>
                        <span class="n">ext_bond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
            <span class="n">xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">get_com</span><span class="p">(</span><span class="n">cidx</span><span class="p">))</span>
            <span class="c1">#xyz.append(self.center(cxyz))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster </span><span class="si">%s</span><span class="s2"> consisting of </span><span class="si">%d</span><span class="s2"> atoms is </span><span class="si">%d</span><span class="s2"> times connected&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">cluster_atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ext_bond</span><span class="p">)))</span>
            <span class="c1"># now check to which clusters these external bonds belong to</span>
            <span class="k">for</span> <span class="n">ea</span> <span class="ow">in</span> <span class="n">ext_bond</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ji</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ea</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -&gt; bonded to cluster &quot;</span><span class="p">,</span> <span class="n">ji</span><span class="p">)</span>
                        <span class="n">tm</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ji</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
        <span class="c1">### check for consistence of conn</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tm</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tm</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fragment topology is inconsitent&quot;</span><span class="p">)</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_xyz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">))</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_elems</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_atypes</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">natoms</span><span class="o">*</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">set_wrapping_cell</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">ctab</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">get_conn_as_tab</span><span class="p">(</span><span class="n">pconn_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_ctab_from_conn</span><span class="p">(</span><span class="n">pconn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">set_etab</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">color_clusters</span><span class="p">:</span>
            <span class="n">type_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_clusters</span><span class="p">()</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">elems</span> <span class="o">=</span> <span class="p">[</span><span class="n">vcolor2elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_clusters</span><span class="p">]</span>
        <span class="n">tg</span> <span class="o">=</span> <span class="n">topograph</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">allow_2conns</span><span class="p">)</span>
        <span class="n">tg</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tg</span></div></div>
    

<div class="viewcode-block" id="topograph"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph">[docs]</a><span class="k">class</span> <span class="nc">topograph</span><span class="p">(</span><span class="n">conngraph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class handles the analysis of nets using graph theory. &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">allow_2conns</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - mol: molsys.topo object</span>
<span class="sd">        - allow_2conns: if False, all 2-connected vertices will be deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_2conns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol_2conns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midx_2conns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_2conns_from_mol</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
        <span class="k">return</span>
    
<div class="viewcode-block" id="topograph.remove_2conns_from_mol"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.remove_2conns_from_mol">[docs]</a>    <span class="k">def</span> <span class="nf">remove_2conns_from_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all vertices with 2 connecting edges from self.mol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make mid-edge atom lists</span>
        <span class="n">delete_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">delete_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># delete atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">(</span><span class="n">delete_list</span><span class="p">,</span> <span class="n">keep_conn</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">## recompute pconn (since delete_atoms is experimental)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_ctab_from_conn</span><span class="p">(</span><span class="n">pconn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_etab_from_tabs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">delete_list</span></div>
    
<div class="viewcode-block" id="topograph.graph2topo"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.graph2topo">[docs]</a>    <span class="k">def</span> <span class="nf">graph2topo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a molsys.topo object (topology) created from the Graph,</span>
<span class="sd">        which can be used to create a graphical representation of the Graph viewable</span>
<span class="sd">        in molden, VMD or similar programs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="topograph.get_all_cs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_all_cs">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">use_atypes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates all cs (coordination sequence) values of the graph.</span>
<span class="sd">        This function just loops over all vertices and calls get_cs for each one</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - depth: maximum level</span>
<span class="sd">        - use_atypes: if this is True, then every vertex with the same atomtype will only be calculated once. </span>
<span class="sd">                      (do NOT use this for topographs deconstructed from a molgraph !!!)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compute all coordination sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_atypes</span><span class="p">:</span>
            <span class="n">vertexlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">found_atypes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">found_atypes</span><span class="p">:</span>
                    <span class="n">found_atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">vertexlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertexlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">))</span>
        <span class="n">cs_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vertexlist</span><span class="p">:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cs</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">cs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cs_list</span></div>

<div class="viewcode-block" id="topograph.get_cs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_cs">[docs]</a>    <span class="k">def</span> <span class="nf">get_cs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">start_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_cell</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the cs (coordination sequence) values of the vertex specified in start_vertex and start_cell.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - depth: maximum level</span>
<span class="sd">        - start_vertex: ID of vertex, of which the cs value should be calculated</span>
<span class="sd">        - start_cell: starting cell of the function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
            <span class="c1"># the normal construction &quot;if x not in y&quot; does not work if arrays are somehow involved inside a list</span>
            <span class="c1"># thus, we need this helper function which is probably terribly slow (if anyone has a better solution, please let me hear it)</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">found</span>
        <span class="c1"># create cs with an appropriate length.</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">depth</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># now, if we want to have a cs_n value, we need to get all neighbours, then do the same thing for all neighbour&#39;s</span>
        <span class="c1"># neighbours, and continue as many times as necessary.</span>
        <span class="c1"># however, we must not start looking at the neighbour&#39;s neighbours before we looked at ALL neighbours, and set them</span>
        <span class="c1"># into the ignore list!</span>
        <span class="n">ignore_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">start_vertex</span><span class="p">,</span> <span class="n">start_cell</span><span class="p">]]</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[[</span><span class="n">start_vertex</span><span class="p">,</span> <span class="n">start_cell</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">neighbours2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#print(&quot;--------- level &quot;+str(level)+&quot; -----------&quot;)</span>
            <span class="c1">#print(&quot;neighbours: &quot;+str(neighbours))</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="c1"># get the neighbours of the neighbours and add them to the list neighbours2</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cs1</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">contains</span><span class="p">(</span><span class="n">neighbours2</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">contains</span><span class="p">(</span><span class="n">ignore_list</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                            <span class="n">neighbours2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="c1">#print(&quot;ignore_list: &quot; +str(ignore_list))</span>
            <span class="c1"># put the neighbours2 into the ignore list</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">neighbours2</span><span class="p">:</span>
                <span class="n">ignore_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
            <span class="c1">#print(&quot;neighbours2: &quot;+str(neighbours2))</span>
            <span class="c1"># the neighbours2 are all the vertices which can be reached with the cs_level operation.</span>
            <span class="n">cs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbours2</span><span class="p">)</span>
            <span class="c1"># if we want to repeat the procedure for the cs_(level+1) operation we have to make the neighbours2 to the neighbours</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">neighbours2</span>
            <span class="c1"># and remove neighbours2 because of side effects</span>
            <span class="k">del</span><span class="p">(</span><span class="n">neighbours2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cs</span></div>

<div class="viewcode-block" id="topograph.get_cs1"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_cs1">[docs]</a>    <span class="k">def</span> <span class="nf">get_cs1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_cell</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot; This function will return all vertices, which are connected to the vertex start_vertex in the cell start_cell. &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop over all neighbouring clusters and add them to the list</span>
        <span class="k">for</span> <span class="n">nj</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]):</span>
            <span class="n">current_vertex</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">current_cell</span> <span class="o">=</span> <span class="n">start_cell</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">current_vertex</span><span class="p">,</span> <span class="n">current_cell</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">visited</span></div>

<div class="viewcode-block" id="topograph.get_all_vs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_all_vs">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_vs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_atypes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wells</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates all vertex symbols of the graph.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - use_atypes (bool): if this is True, then every vertex with the same atomtype will only be calculated once.</span>
<span class="sd">        - wells (bool): If True, the Wells and the long symbols will be returned. If False, only the long symbols are used</span>
<span class="sd">        - max_supercell_size (int): throws OverflowError if supercell_size &gt; max_supercell_size</span>
<span class="sd">            (same error as if max_supercell_size is infinite and get_all_vs fails)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compute all vertex symbols&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_atypes</span><span class="p">:</span>
            <span class="n">vertexlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">found_atypes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">found_atypes</span><span class="p">:</span>
                    <span class="n">found_atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">vertexlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertexlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="p">))</span>
        <span class="n">vs_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">supercells</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)]</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vertexlist</span><span class="p">:</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">supercell_size</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">supercell_size</span> <span class="o">&gt;</span> <span class="n">max_supercell_size</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Maximum cell size (</span><span class="si">%s</span><span class="s2">) reached!&quot;</span> <span class="o">%</span> <span class="n">max_supercell_size</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">OverflowError</span>
                <span class="k">if</span> <span class="n">supercell_size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">supercells</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">([</span><span class="n">supercell_size</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">supercells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">supercells</span><span class="p">[</span><span class="n">supercell_size</span><span class="p">]</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ws</span><span class="p">,</span> <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_symbol</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">supercell_size</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">keep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">wells</span><span class="p">:</span> 
                <span class="n">vs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">ls</span>
            <span class="n">vs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vs_list</span></div>
    
<div class="viewcode-block" id="topograph.get_vertex_symbol"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_vertex_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In the vertex symbol, the number of the shortest ring at each angle of a vertex is given with</span>
<span class="sd">        the number of such rings in brackets (originally: subscript, but this can&#39;t be realized in</span>
<span class="sd">        python).</span>
<span class="sd">        Relevant literature: O. Delgado-Friedrichs, M. O&#39;Keeffe, Journal of Solid State Chemistry 178, 2005, p. 2480ff.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Topology only consists of only one vertex&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">vertex_symbol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span><span class="o">.</span><span class="n">all_neighbours</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">filled</span><span class="p">,</span> <span class="n">inverted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">asp</span> <span class="o">=</span> <span class="n">all_shortest_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">clear_filters</span><span class="p">()</span>
                    <span class="n">append_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">asp</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_vertex</span><span class="p">]</span><span class="o">+</span><span class="n">path</span>
                        <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cycle_voltage</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cycle with non zero voltage detected&quot;</span><span class="p">)</span>
                        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_vertex</span><span class="p">)</span>
                        <span class="n">append_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">append_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">vertex_symbol</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">append_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">append_list</span><span class="p">)))</span>
        <span class="n">ws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_wells_symbol</span><span class="p">(</span><span class="n">vertex_symbol</span><span class="p">)</span>
        <span class="n">ls</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">compute_long_symbol</span><span class="p">(</span><span class="n">vertex_symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ws</span><span class="p">,</span> <span class="n">ls</span></div>

<div class="viewcode-block" id="topograph.compute_wells_symbol"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.compute_wells_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">compute_wells_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clist</span><span class="p">):</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">clist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clist</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">sclist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sclist</span><span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">clist</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">^</span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">count</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">symbol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="topograph.compute_long_symbol"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.compute_long_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">compute_long_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">clist</span><span class="p">):</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="nb">int</span><span class="p">),(</span><span class="s2">&quot;number&quot;</span><span class="p">,</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">clist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clist</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sclist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">clist</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="s2">&quot;number&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sclist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
        <span class="k">return</span> <span class="n">symbol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="topograph.get_cycle_voltage"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_cycle_voltage">[docs]</a>    <span class="k">def</span> <span class="nf">get_cycle_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
        <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">vol</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">pconn</span><span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">cidx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">vol</span></div>

<div class="viewcode-block" id="topograph.get_unique_vd"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.get_unique_vd">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_vd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">atype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the unique cs values and vertex symbols (&quot;vertex descriptors&quot;, vd). </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - cs: list of cs values</span>
<span class="sd">        - vs: list of vertex symbols</span>
<span class="sd">        - atype: If this is True, the function also changes the atomtypes in the </span>
<span class="sd">          topograph (i.e. the &quot;vertex types&quot;), according to the different vertex </span>
<span class="sd">          descriptors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Get unique vertex descriptors&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">uvd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">atcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">vs</span><span class="p">):</span>
            <span class="n">vd</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">v</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uvd</span><span class="p">:</span> 
                <span class="n">uvd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vd</span><span class="p">)</span>
                <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atcount</span><span class="p">))</span>
                <span class="n">atcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">uvd</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">vd</span><span class="p">)))</span>
        <span class="n">ucs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">uvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uvd</span><span class="p">:</span>
            <span class="n">ucs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">uvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">atype</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_atypes</span><span class="p">(</span><span class="n">atypes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ucs</span><span class="p">,</span> <span class="n">uvs</span></div>

<div class="viewcode-block" id="topograph.build_coordination_pattern"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.build_coordination_pattern">[docs]</a>    <span class="k">def</span> <span class="nf">build_coordination_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern</span><span class="p">,</span> <span class="n">cn</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">assert</span> <span class="n">cn</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">cn</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1">### build subgraph</span>
        <span class="n">patg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span> <span class="o">=</span> <span class="n">patg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">patg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">patg</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
            <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
        <span class="n">patg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">patg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">patg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">patg</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
                <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cn</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>
                <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
                <span class="n">patg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">patg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">patg</span></div>

<div class="viewcode-block" id="topograph.build_coordination_pattern_from_mol"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.build_coordination_pattern_from_mol">[docs]</a>    <span class="k">def</span> <span class="nf">build_coordination_pattern_from_mol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mol</span><span class="p">):</span>
        <span class="n">atypes</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">get_atypes</span><span class="p">()</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atypes</span><span class="p">:</span>
            <span class="n">sa</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">sa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">,</span><span class="s2">&quot;p&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">cns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">addon</span><span class="p">(</span><span class="s2">&quot;graph&quot;</span><span class="p">)</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">make_graph</span><span class="p">()</span>
        <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cns</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">mol</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">molg</span></div>

<div class="viewcode-block" id="topograph.search_coordination_pattern"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.search_coordination_pattern">[docs]</a>    <span class="k">def</span> <span class="nf">search_coordination_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">patg</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">patg</span><span class="p">)</span> <span class="o">==</span> <span class="n">Graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s2">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">()))</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">patg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">vertex_label</span> <span class="o">=</span>
                <span class="p">(</span><span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">cn</span><span class="p">))</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">smaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">maps</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">sl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span> 
                <span class="n">subs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
                <span class="n">smaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smaps</span></div>

<div class="viewcode-block" id="topograph.collapse_subs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topograph.collapse_subs">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">patg</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">patg</span><span class="p">)</span> <span class="o">==</span> <span class="n">Graph</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">### search centers,removals and planets</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">maps</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">planets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#v = self.molg.add_vertex()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">patg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span> 
                <span class="k">if</span> <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
                    <span class="n">center</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">patg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span>
                    <span class="n">planets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">cidx</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">center</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
                <span class="n">dl</span> <span class="o">+=</span> <span class="n">center</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_unit_mass</span><span class="p">()</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">get_com</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vp</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;n&#39;</span><span class="p">,</span><span class="n">xyz</span><span class="p">)</span>
                <span class="n">cidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No Center Vertex found&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">vidx</span> <span class="ow">in</span> <span class="n">planets</span><span class="p">:</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vidx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">cidx</span><span class="p">,</span><span class="n">vidx</span><span class="p">)</span>
                <span class="c1">#self.mol.conn[cidx].append(vidx)</span>
                <span class="c1">#self.mol.conn[vidx].append(cidx)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dl</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">delete_atom</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">add_pconn</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_ctab_from_conn</span><span class="p">(</span><span class="n">pconn_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">set_etab_from_tabs</span><span class="p">()</span>
        <span class="k">return</span></div></div>

<div class="viewcode-block" id="topotyper"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper">[docs]</a><span class="k">class</span> <span class="nc">topotyper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrapper class which combines molgraph and topograph for the deconstruction of MOF structures. &quot;&quot;&quot;</span>
  
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">split_by_org</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">isum</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">trip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - mol (obj): molsys.mol object which should be deconstructed</span>
<span class="sd">        - split_by_org (bool): if True, organicity is used for defining building blocks</span>
<span class="sd">        - depth (int): maximum level of coordination sequences </span>
<span class="sd">        - isum (int*): summation of indices</span>
<span class="sd">        - trip (nested tuples*): resizing list for make_supercell if vertex symbols method overflows</span>
<span class="sd">            * recursive purpose, DO NOT CHANGE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#molcopy = copy.deepcopy(mol) #prevents mol pollution if restart ###DOES NOT WORK WITH CIF FILES</span>
        <span class="n">molcopy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="c1">#prevents mol pollution if restart</span>
        <span class="n">goodinit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mg</span> <span class="o">=</span> <span class="n">molgraph</span><span class="p">(</span><span class="n">molcopy</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">goodinit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">trip</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trinat</span> <span class="o">=</span> <span class="n">triplenats_on_sphere</span><span class="p">(</span><span class="n">isum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trinat</span> <span class="o">=</span> <span class="n">trip</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trinat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">itri</span> <span class="o">=</span> <span class="n">trinat</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Triplet is: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">itri</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">isum</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span> <span class="n">mol</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">itri</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">(</span><span class="n">split_by_org</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="n">max_supercell_size</span><span class="p">)</span>
                    <span class="n">goodinit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="ne">OverflowError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c1"># specific for supercells</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Deconstruction failed! Resize original cell&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">split_by_org</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="n">max_supercell_size</span><span class="p">,</span> <span class="n">isum</span><span class="o">=</span><span class="n">isum</span><span class="p">,</span><span class="n">trip</span><span class="o">=</span><span class="n">trinat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Resizing list is empty! Increase index summation to </span><span class="si">%i</span><span class="s2"> and create new resizing list&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isum</span><span class="p">,))</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">split_by_org</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="n">max_supercell_size</span><span class="p">,</span> <span class="n">isum</span><span class="o">=</span><span class="n">isum</span><span class="p">)</span>
        <span class="k">return</span>
 
<div class="viewcode-block" id="topotyper.deconstruct"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.deconstruct">[docs]</a>    <span class="k">def</span> <span class="nf">deconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_by_org</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_supercell_size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform deconstruction &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Perform topological deconstruction&#39;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">handle_islands</span><span class="p">(</span><span class="n">silent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;handle_islands </span><span class="si">%5.1f</span><span class="s1">&#39;</span>  <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">determine_Nk</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;determine_Nk </span><span class="si">%5.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">find_cluster_threshold</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;find_cluster_threshold </span><span class="si">%5.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">get_clusters</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;get_clusters </span><span class="si">%5.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">split_by_org</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">get_bbs_by_organicity</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">get_bbs</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;get_bbs </span><span class="si">%5.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">make_topograph</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;make_topograph </span><span class="si">%5.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t1</span><span class="p">),);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#cs = self.tg.get_all_cs(depth=depth)</span>
        <span class="c1">#print(&#39;get_all_cs %5.1f&#39; % (time.time()-t1),); t1 = time.time()</span>
        <span class="c1">#vs = self.tg.get_all_vs(max_supercell_size=max_supercell_size)</span>
        <span class="c1">#print(&#39;get_all_vs %5.1f&#39; % (time.time()-t1),); t1 = time.time()</span>
        <span class="c1">#self.cs, self.vs = self.tg.get_unique_vd(cs, vs)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topotyper.compute_colors"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.compute_colors">[docs]</a>    <span class="k">def</span> <span class="nf">compute_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute edge coloring (TBI: vertex coloring)</span>
<span class="sd">        </span>
<span class="sd">        sort_flag (bool): if it is True: colors are sorted according to</span>
<span class="sd">            increasing color signature</span>

<span class="sd">        &gt;&gt;&gt; import molsys</span>
<span class="sd">        &gt;&gt;&gt; from molsys.util import toper</span>
<span class="sd">        &gt;&gt;&gt; m = molsys.mol.from_file(&quot;jast-1&quot;) # as example</span>
<span class="sd">        &gt;&gt;&gt; tt = toper.topotyper(m) # may need time</span>
<span class="sd">        &gt;&gt;&gt; tt.compute_colors()</span>
<span class="sd">        &gt;&gt;&gt; from molsys.util.color import make_mol # TBI: colors I/O</span>
<span class="sd">        &gt;&gt;&gt; ecolors = tt.tg.molg.ep.color.a</span>
<span class="sd">        &gt;&gt;&gt; n = make_mol(tt.tg.mol, alpha=3, ecolors=ecolors)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbs</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_bbs</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Perform topological coloring&#39;</span><span class="p">)</span>
        <span class="c1">### TBI: vertex coloring</span>
        <span class="c1">### vertices = range(self.tg.mol.natoms) # the clusters</span>
        <span class="c1">### vertexcolors = np.zeros(len(vertices), dtype=int)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ### PREVIOUS IMPLEMENTATION ###</span>
<span class="sd">        #edges = self.tg.mol.ctab</span>
<span class="sd">        #edgecolors = np.zeros(len(edges), dtype=int)</span>
<span class="sd">        #...</span>
<span class="sd">        #for iedge, edge in enumerate(self.tg.molg.edges()):</span>
<span class="sd">        #    ...</span>
<span class="sd">        #    edgecolors[iedge] = colorsigns[sign]</span>
<span class="sd">        ###############################</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">list2c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">midx_2conns</span>
        <span class="n">vertex_bb_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">list2c</span><span class="p">)):</span>
            <span class="k">del</span> <span class="n">vertex_bb_list</span><span class="p">[</span><span class="n">vertex_bb_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="n">colorsigns</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># color signatures</span>
        <span class="n">clustsigns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">etab</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">etab</span><span class="p">)),</span> \
            <span class="s2">&quot;edges w/ same termini (i.e. when pconn is needed) is NOT supported [TBI]&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="c1"># v,u are source,target vertex of the edge</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">vertex_bb_list</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">source</span><span class="p">())]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">vertex_bb_list</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">target</span><span class="p">())]</span>
            <span class="c1"># unique block names</span>
            <span class="n">ubbv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">ubbu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="c1"># signature</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_color_signature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">sign</span><span class="p">,()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># colors are edge midpoints</span>
                <span class="c1"># workaround: since edges are no more stored in tg we use</span>
                <span class="c1"># directly mg. This will be SLOW</span>
                <span class="c1"># TBI: use tg (maybe w/ self.tg.mol_2conns.conn)</span>
                <span class="c1"># cluster atoms</span>
                <span class="n">clustv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">clustu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="c1">## cluster connectivity</span>
                <span class="n">connv</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clustv</span><span class="p">]</span>
                <span class="n">connu</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clustu</span><span class="p">]</span>
                <span class="n">allconnv</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">connv</span><span class="p">,[])</span>
                <span class="n">allconnu</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">connu</span><span class="p">,[])</span>
                <span class="n">allconnv_</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allconnv</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">v</span><span class="p">]</span>
                <span class="n">allconnu_</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allconnu</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">u</span><span class="p">]</span>
                <span class="c1">## midpoint cluster</span>
                <span class="n">allconnt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">allconnv_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">allconnu_</span><span class="p">))</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">allconnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>\
                    <span class="s2">&quot;only 1 edge must be btw. 2 vertices&quot;</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">allconnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># the only one</span>
                <span class="n">ubbt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">sign1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_color_signature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">sign2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_color_signature</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">ubbt</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">sign1</span><span class="p">,</span><span class="n">sign2</span><span class="p">])))</span>
                <span class="c1">#if sign1 == sign2:</span>
                <span class="c1">#    sign = ubbt ### JUST the cluster type!</span>
                <span class="c1">#else:</span>
                <span class="c1">#    raise NotImplementedError(&quot;TBI: edge midpoints w/ orient colors&quot;)</span>
            <span class="c1"># order (int) of occurrence assigned as color to the edge</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">colorsigns</span><span class="p">:</span>
                <span class="n">colorsigns</span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colorsigns</span><span class="p">)</span> <span class="c1"># starting from 0</span>
                <span class="c1">#clustsigns[sign] = (ubbv, ubbu)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">colorsigns</span><span class="p">[</span><span class="n">sign</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sort_flag</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># sort colors according to color signature lexsorting</span>
            <span class="c1"># it is invariant wrt. order of occurrence</span>
            <span class="c1"># it sorts just the colortypes</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">colorsigns</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
            <span class="n">sorting_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">items</span><span class="p">,</span><span class="n">argsorted</span><span class="p">(</span><span class="n">keys</span><span class="p">))))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorting_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topotyper.write_colors"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.write_colors">[docs]</a>    <span class="k">def</span> <span class="nf">write_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldername</span><span class="o">=</span><span class="s2">&quot;colors&quot;</span><span class="p">,</span> <span class="n">index_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;color&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_colors</span><span class="p">(</span><span class="n">sort_flag</span><span class="o">=</span><span class="n">sort_flag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_run</span><span class="p">:</span>
            <span class="n">foldername</span> <span class="o">=</span> <span class="n">_checkrundir</span><span class="p">(</span><span class="n">foldername</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_makedirs</span><span class="p">(</span><span class="n">foldername</span><span class="p">)</span>

        <span class="n">asort</span> <span class="o">=</span> <span class="n">argsorted</span><span class="p">([(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()),</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">asort</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">make_mol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ecolors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">molg</span><span class="o">.</span><span class="n">ep</span><span class="o">.</span><span class="n">color</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">scell</span><span class="p">)</span>
        <span class="n">n</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s%s</span><span class="s2">.mfpx&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">foldername</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">))</span>
        <span class="n">n</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s%s</span><span class="s2">.txyz&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">foldername</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">),</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">foldername</span></div>

<div class="viewcode-block" id="topotyper.get_color_signature"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_color_signature">[docs]</a>    <span class="k">def</span> <span class="nf">get_color_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get color signature taking the connecting atoms at the boundary of the blocks</span>
<span class="sd">        TBI: atom sequence going &quot;inside&quot; the block instead of just connecting atoms</span>

<span class="sd">        v(int): vertex with index v</span>
<span class="sd">        u(int): vertex with index u</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># cluster atoms</span>
        <span class="n">clustv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">clustu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="c1"># cluster connectivity</span>
        <span class="n">connv</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">jc</span> <span class="k">for</span> <span class="n">jc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="k">if</span> <span class="n">jc</span> <span class="ow">in</span> <span class="n">clustu</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">clustv</span>
        <span class="p">]</span>
        <span class="n">connu</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">jc</span> <span class="k">for</span> <span class="n">jc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="k">if</span> <span class="n">jc</span> <span class="ow">in</span> <span class="n">clustv</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">clustu</span>
        <span class="p">]</span>
        <span class="c1"># cluster connectivity towards each other</span>
        <span class="c1"># TBI: atom sequence in that direction</span>
        <span class="n">connv_</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ic</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connv</span><span class="p">)</span> <span class="k">if</span> <span class="n">ic</span> <span class="o">!=</span> <span class="p">[]]</span>
        <span class="n">connu_</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ic</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connu</span><span class="p">)</span> <span class="k">if</span> <span class="n">ic</span> <span class="o">!=</span> <span class="p">[]]</span>
        <span class="c1"># connecting atoms == cluster atoms at the frontier of each other</span>
        <span class="n">clustv_</span> <span class="o">=</span> <span class="p">[</span><span class="n">clustv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connv_</span><span class="p">]</span>
        <span class="n">clustu_</span> <span class="o">=</span> <span class="p">[</span><span class="n">clustu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connu_</span><span class="p">]</span>
        <span class="c1"># elements of the connecting atoms</span>
        <span class="c1"># N.B.: sorted for consistency, tupled for hashability as dict key</span>
        <span class="c1"># TBI: choice of elemsequences</span>
        <span class="n">elemsv</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clustv_</span><span class="p">]))</span>
        <span class="n">elemsu</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clustu_</span><span class="p">]))</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">elemsv</span><span class="p">,</span> <span class="n">elemsu</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">sign</span></div>

<div class="viewcode-block" id="topotyper.get_net"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_net">[docs]</a>    <span class="k">def</span> <span class="nf">get_net</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Connects to mofplus API to compare the cs and vs value to the database, and return the topology. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api</span> <span class="o">=</span> <span class="n">user_api</span><span class="p">()</span><span class="c1">#experimental=False)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">search_cs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nets</span></div>

<div class="viewcode-block" id="topotyper.tg_atypes_by_isomorphism"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.tg_atypes_by_isomorphism">[docs]</a>    <span class="k">def</span> <span class="nf">tg_atypes_by_isomorphism</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will modify the atomtypes in the topograph (i.e. &quot;vertex types&quot;): If</span>
<span class="sd">        two vertices with the same atomtype have different structures, the atomtype will be</span>
<span class="sd">        changed.</span>
<span class="sd">        Possible todo: compare the elements with each other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cv</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">get_cluster_atoms</span><span class="p">()</span>
        <span class="n">bb_molgraphs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">cluster_organicity</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">detect_organicity</span><span class="p">()</span>
        <span class="c1"># Remove all 2-connected clusters, since they aren&#39;t in the topograph</span>
        <span class="n">list2c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">midx_2conns</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">list2c</span><span class="p">)):</span>
            <span class="k">del</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># check for isomorphism</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ca</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">new_mol_by_index</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">mg</span> <span class="o">=</span> <span class="n">molgraph</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="c1">#print(&quot;i &quot;+str(i))</span>
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bb_molgraphs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mg2</span> <span class="o">=</span> <span class="n">bb_molgraphs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1">#print(&quot;  j &quot;+str(j))</span>
                <span class="k">if</span> <span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mg2</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">isomorphism</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">mg2</span><span class="o">.</span><span class="n">molg</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;#&quot;</span>
                            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bb_molgraphs</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">bb_molgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ascii_lowercase</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="topotyper.get_all_atomseq"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_all_atomseq">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_atomseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates all atomseq (atom sequences) of the molecule according to their elements..</span>
<span class="sd">        This function just loops over all vertices and calls get_atomseq for each one</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - depth: maximum level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Compute all atom sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbbs</span><span class="p">))</span>
        <span class="n">atomseqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">atomseq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atomseq</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">atomseqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomseq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomseqs</span> <span class="o">=</span> <span class="n">atomseqs</span>
        <span class="k">return</span> <span class="n">atomseqs</span></div>

<div class="viewcode-block" id="topotyper.get_atomseq"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_atomseq">[docs]</a>    <span class="k">def</span> <span class="nf">get_atomseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">start_cluster</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
        <span class="c1">###TBI: implement start_cell!</span>
        <span class="c1">###start_cell IS NEEDED for images</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the as (atom sequence) of the vertex specified in start_vertex and start_cell.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - depth: maximum level</span>
<span class="sd">        - start_vertex: ID of vertex, of which the cs value should be calculated</span>
<span class="sd">        - start_cell: starting cell of the function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ignore</span><span class="p">,</span> <span class="n">return_set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span><span class="p">[</span><span class="n">ia</span><span class="p">])</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>
            <span class="n">conn</span> <span class="o">-=</span> <span class="n">ignore</span>
            <span class="k">if</span> <span class="n">return_set</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">conn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">atomconn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2conn</span><span class="p">[</span><span class="n">start_cluster</span><span class="p">]</span>
        <span class="n">nconn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomconn</span><span class="p">)</span>
        <span class="n">ignore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">start_cluster</span><span class="p">]</span>
        <span class="n">ignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span>
        <span class="n">atomseq</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nconn</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">iconn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atomconn</span><span class="p">):</span>
            <span class="n">lever</span> <span class="o">=</span> <span class="p">[</span><span class="n">iconn</span><span class="p">]</span> <span class="c1">#for depth == 0</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
                <span class="n">levseq</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">leverneigh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">lever</span><span class="p">:</span>
                        <span class="n">neigh</span> <span class="o">=</span> <span class="n">connected</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span><span class="n">ignore</span><span class="p">)</span>
                        <span class="n">leverneigh</span> <span class="o">|=</span> <span class="n">neigh</span>
                <span class="k">if</span> <span class="n">neigh</span><span class="p">:</span>
                    <span class="n">leverneigh</span> <span class="o">-=</span> <span class="n">ignore</span> <span class="c1">###????</span>
                    <span class="n">ignore</span> <span class="o">|=</span> <span class="n">leverneigh</span>
                    <span class="n">levseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">neigh</span><span class="p">))</span>
                    <span class="n">lever</span> <span class="o">=</span> <span class="n">leverneigh</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">atomseq</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+=</span> <span class="n">levseq</span>
            <span class="n">atomseq</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">atomseq</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span> <span class="c1">###</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">atomseq</span><span class="p">)</span></div>

<div class="viewcode-block" id="topotyper.atomseq2elemseq"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.atomseq2elemseq">[docs]</a>    <span class="k">def</span> <span class="nf">atomseq2elemseq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span>
        <span class="n">atomseq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomseq</span>
        <span class="c1">#elemseq = [[] for i in range(len(atomseq))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atomseq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>
        <span class="c1">#for i,ai in enumerate(atomseq):</span>
        <span class="c1">#    print(i)</span>
        <span class="c1">#    for j in ai:</span>
        <span class="c1">#        for k in j:</span>
        <span class="c1">#            print(elems[k], end=&quot; &quot;)</span>
        <span class="c1">#        print()</span>
        <span class="c1">#    #print(i, ai)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topotyper.compute_bbs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.compute_bbs">[docs]</a>    <span class="k">def</span> <span class="nf">compute_bbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">org_flag</span><span class="o">=</span><span class="s2">&quot;_ORG&quot;</span><span class="p">,</span> <span class="n">ino_flag</span><span class="o">=</span><span class="s2">&quot;_INO&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute building blocks</span>

<span class="sd">        &gt;&gt;&gt; import molsys</span>
<span class="sd">        &gt;&gt;&gt; from molsys.util import toper</span>
<span class="sd">        &gt;&gt;&gt; m = molsys.mol.from_file(&quot;jast-1&quot;) # as example</span>
<span class="sd">        &gt;&gt;&gt; tt = toper.topotyper(m) # may need time</span>
<span class="sd">        &gt;&gt;&gt; tt.compute_bbs()</span>
<span class="sd">        &gt;&gt;&gt; tt.write_bbs()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Perform topological deconstruction in blocks&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tg_atypes_by_isomorphism</span><span class="p">()</span>
        <span class="n">cv</span><span class="p">,</span> <span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">get_cluster_atoms</span><span class="p">()</span>
        <span class="n">bbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">organicity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ca</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">new_mol_by_index</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">bbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">cluster_organicity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">organicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">org_flag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">organicity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ino_flag</span><span class="p">)</span>
        <span class="c1"># prepare vertex_bb_list (to translate indices of a list with 2-connected clusters to those of one without them)</span>
        <span class="n">list2c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">midx_2conns</span>
        <span class="n">vertex_bb_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">list2c</span><span class="p">)):</span>
            <span class="k">del</span> <span class="n">vertex_bb_list</span><span class="p">[</span><span class="n">vertex_bb_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="c1"># Use the atomtypes to identify &quot;vertex&quot; BBs</span>
        <span class="n">atomtype_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atypes</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">atomtype_dict</span><span class="p">[</span><span class="n">atype</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">atomtype_dict</span><span class="p">[</span><span class="n">atype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">atomtype_dict</span><span class="p">[</span><span class="n">atype</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex_bb_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">unique_bbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cluster_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">atomtype_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">unique_bbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomtype_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">cluster_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># determine which of the clusters are &quot;edge&quot; BBs and</span>
        <span class="c1"># Check to which vertex BBs the edge BBs are connected</span>
        <span class="n">cluster_conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">cluster_conn</span><span class="p">()</span>
        <span class="n">neighbour_atypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique_2c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c2ubb</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list2c</span><span class="p">:</span>
            <span class="n">neighbour_atype</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">cluster_conn</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">atomtype_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">atomtype_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">neighbour_atype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="n">neighbour_atype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">neighbour_atype</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">neighbour_atype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbour_atypes</span><span class="p">:</span>
                <span class="n">neighbour_atypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_atype</span><span class="p">)</span>
                <span class="n">unique_2c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">unique_bbs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="n">c2ubb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bbs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">cluster_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># check for isomorphism</span>
                <span class="n">mg</span> <span class="o">=</span> <span class="n">molgraph</span><span class="p">(</span><span class="n">bbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">isomorphic_with_any</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">unique_2c</span><span class="p">:</span>
                    <span class="n">mg2</span> <span class="o">=</span> <span class="n">molgraph</span><span class="p">(</span><span class="n">bbs</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mg2</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">isomorphism</span><span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">molg</span><span class="p">,</span> <span class="n">mg2</span><span class="o">.</span><span class="n">molg</span><span class="p">):</span>
                            <span class="n">isomorphic_with_any</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">unique_bbs</span><span class="p">[</span><span class="n">c2ubb</span><span class="p">[</span><span class="n">i2</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">c2ubb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2ubb</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># this is a workaround, so multiple edge BBs with 1 atom will always be isomorphic...</span>
                        <span class="n">isomorphic_with_any</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isomorphic_with_any</span><span class="p">:</span>
                    <span class="n">unique_2c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">unique_bbs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">c2ubb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bbs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cluster_names</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;-&quot;</span><span class="o">+</span><span class="n">neighbour_atype</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ascii_lowercase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cluster_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bbs</span> <span class="o">=</span> <span class="n">bbs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_bbs</span> <span class="o">=</span> <span class="n">unique_bbs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_names</span> <span class="o">=</span> <span class="n">cluster_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">organicity</span> <span class="o">=</span> <span class="n">organicity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_atom2bb</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_bb2ubb</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detect_connectors</span><span class="p">()</span>
        <span class="c1">### BUG HERE ###</span>
        <span class="c1">#self.detect_all_connectors()</span>
        <span class="c1">#self.set_conn2bb()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topotyper.detect_connectors"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.detect_connectors">[docs]</a>    <span class="k">def</span> <span class="nf">detect_connectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ubbs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique_bbs</span><span class="p">:</span>
            <span class="n">ubb</span> <span class="o">=</span> <span class="n">ubbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># assumption</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbs</span><span class="p">[</span><span class="n">ubb</span><span class="p">]</span>
            <span class="n">bbatoms_mg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">ubb</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bb</span><span class="o">.</span><span class="n">elems</span> <span class="o">!=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bbatoms_mg</span><span class="p">]:</span> <span class="c1"># this is the assumption</span>
                <span class="n">bb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">new_mol_by_index</span><span class="p">(</span><span class="n">bbatoms_mg</span><span class="p">)</span>
                <span class="c1"># next line is needed since atoms are sorted according to</span>
                <span class="c1">#   previous order, not according the given bbatoms_mg order</span>
                <span class="n">bbatoms_mg</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="c1">### DEBUG ### try to remove the previous line and see what happens</span>
                <span class="c1">#for kk,k in enumerate(bbatoms_mg):</span>
                <span class="c1">#    print(</span>
                <span class="c1">#    &quot;%s == %s? %s&quot; % (</span>
                <span class="c1">#        bb.elems[kk], self.mg.mol.elems[k], bb.elems[kk] == self.mg.mol.elems[k]</span>
                <span class="c1">#        )</span>
                <span class="c1">#)</span>
                <span class="c1">### END DEBUG ###</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bbs</span><span class="p">[</span><span class="n">ubb</span><span class="p">]</span> <span class="o">=</span> <span class="n">bb</span> <span class="c1"># NOT SURE</span>
            <span class="n">connectors</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># to be converted later</span>
            <span class="n">connector_atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">connectors_sign</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">connectors_type</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">ctab</span><span class="p">):</span>
                <span class="n">iin</span> <span class="o">=</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bbatoms_mg</span>
                <span class="n">jin</span> <span class="o">=</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bbatoms_mg</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iin</span> <span class="o">^</span> <span class="n">jin</span><span class="p">:</span> <span class="c1">#both or none</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">jin</span><span class="p">:</span> <span class="c1"># reverse</span>
                    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span><span class="n">i</span>
                <span class="n">ie</span><span class="p">,</span> <span class="n">je</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">iabb</span><span class="p">,</span> <span class="n">jabb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">iubb</span><span class="p">,</span> <span class="n">jubb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">iabb</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">jabb</span><span class="p">]</span>
                <span class="n">connectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bbatoms_mg</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="n">connector_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bbatoms_mg</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="n">connectors_sign</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ie</span><span class="p">,</span><span class="n">je</span><span class="p">,</span><span class="n">iubb</span><span class="p">,</span><span class="n">jubb</span><span class="p">))</span>
            <span class="n">connectors_signtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">connectors_sign</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">sign2type</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">e</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connectors_signtype</span><span class="p">)])</span>
            <span class="n">connectors_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign2type</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">connectors_sign</span><span class="p">]</span>
            <span class="c1"># center in box</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">center_com</span><span class="p">(</span><span class="n">check_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">wrap_in_box</span><span class="p">()</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">bcond</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">addon</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">)</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">is_bb</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">connectors</span> <span class="o">=</span> <span class="n">connectors</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">connector_atoms</span> <span class="o">=</span> <span class="n">connector_atoms</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">connectors_type</span> <span class="o">=</span> <span class="n">connectors_type</span>
            <span class="n">bb</span><span class="o">.</span><span class="n">center_point</span> <span class="o">=</span> <span class="s1">&#39;coc&#39;</span></div>
    
<div class="viewcode-block" id="topotyper.write_bbs"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.write_bbs">[docs]</a>    <span class="k">def</span> <span class="nf">write_bbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foldername</span><span class="o">=</span><span class="s2">&quot;bbs&quot;</span><span class="p">,</span> <span class="n">index_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">org_flag</span><span class="o">=</span><span class="s2">&quot;_ORG&quot;</span><span class="p">,</span> <span class="n">ino_flag</span><span class="o">=</span><span class="s2">&quot;_INO&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the clusters of the molgraph into the folder specified in the parameters.</span>
<span class="sd">        The names of the clusters written out will be those of the atomtypes of the vertices</span>
<span class="sd">        in the topograph, if they are &quot;vertex&quot; building blocks (i.e. they have more than</span>
<span class="sd">        2 neighbours). If they are &quot;edge&quot; building blocks (they have exactly 2 neighbours),</span>
<span class="sd">        their name will be the atomtypes of the vertex BBs they are connected to.</span>
<span class="sd">        Additionally, at the end of the filename, a string defined by the parameters org_flag</span>
<span class="sd">        and ino_flag will be appended to denote whether the BB is organic.</span>
<span class="sd">        </span>
<span class="sd">        :Parameters:</span>
<span class="sd">        - foldername: Name of the folder, in which the mfpx files of the building blocks</span>
<span class="sd">          should be saved.</span>
<span class="sd">        - org_flag: String, which will be added to the filename if the BB is organic.</span>
<span class="sd">        - ino_flag: String, which will be added to the filename if the BB is inorganic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Now write building blocks</span>
        <span class="c1">#print(&quot;============&quot;)</span>
        <span class="c1">#print(unique_bbs)</span>
        <span class="c1">#print(atomtype_dict)</span>
        <span class="c1">#print(organicity)</span>
        <span class="c1">#try:</span>
        <span class="c1">#    print(neighbour_atypes)</span>
        <span class="c1">#except:</span>
        <span class="c1">#    print(&quot;no 2-conns&quot;)</span>
        <span class="c1">#print(&quot;============&quot;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bbs&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_bbs</span><span class="p">(</span><span class="n">org_flag</span><span class="o">=</span><span class="n">org_flag</span><span class="p">,</span> <span class="n">ino_flag</span><span class="o">=</span><span class="n">ino_flag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_run</span><span class="p">:</span>
            <span class="n">foldername</span> <span class="o">=</span> <span class="n">_checkrundir</span><span class="p">(</span><span class="n">foldername</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_makedirs</span><span class="p">(</span><span class="n">foldername</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_bbs</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbs</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">unwrap_box</span><span class="p">()</span>
            <span class="n">m</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">foldername</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_names</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">organicity</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="s2">&quot;.mfpx&quot;</span><span class="p">,</span> <span class="s2">&quot;mfpx&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">foldername</span></div>
        
    <span class="c1">### BUG HERE, CONNECTIVITY IS CHANGED ###</span>
    <span class="c1">#def detect_all_connectors(self):</span>
    <span class="c1">#    ###TBI: RETRIEVE EDGES FROM SELF.TG.MOL.CONN</span>
    <span class="c1">#    self.edges = set(())</span>
    <span class="c1">#    self.bb2conn = []</span>
    <span class="c1">#    self.bb2adj = []</span>
    <span class="c1">#    self.bb2adjconn = []</span>
    <span class="c1">#    for ibb in range(self.nbbs):</span>
    <span class="c1">#        iedges, iledges, idedges, icedges = self.detect_connectors(ibb, return_dict=True)</span>
    <span class="c1">#        self.edges |= set(iedges)</span>
    <span class="c1">#        self.bb2conn.append(iledges)</span>
    <span class="c1">#        self.bb2adj.append(idedges)</span>
    <span class="c1">#        self.bb2adjconn.append(icedges)</span>
    <span class="c1">#    self.edges = list(self.edges)</span>
    <span class="c1">#    self.edges.sort()</span>
    <span class="c1">#    self.tg.mol.set_ctab(self.edges, conn_flag=True)</span>
    <span class="c1">#    self.mol.set_etab_from_tabs()</span>
    <span class="c1">#    self.nedges = len(self.edges)</span>
    <span class="c1">#    return</span>

    <span class="c1">#def detect_connectors(self, ibb, return_dict=False):</span>
    <span class="c1">#    batoms = set(self.mg.clusters[ibb])</span>
    <span class="c1">#    dedges = {}</span>
    <span class="c1">#    cedges = {}</span>
    <span class="c1">#    ledges = []</span>
    <span class="c1">#    edges = []</span>
    <span class="c1">#    for ia in batoms:</span>
    <span class="c1">#        ic = set(self.mg.mol.conn[ia])</span>
    <span class="c1">#        ic -= batoms #set difference</span>
    <span class="c1">#        if ic:</span>
    <span class="c1">#            ic = int(*ic) #safety: if more than 1, raise error</span>
    <span class="c1">#            dedges[ia] = ic #computed anyway</span>
    <span class="c1">#            cedges[self.abb[ic]] = ia</span>
    <span class="c1">#            ledges.append(ia)</span>
    <span class="c1">#            iedges = [ibb, self.abb[ic]]</span>
    <span class="c1">#            iedges.sort()</span>
    <span class="c1">#            edges.append(tuple(iedges)) #needs tuple</span>
    <span class="c1">#    if return_dict:</span>
    <span class="c1">#        return edges, ledges, dedges, cedges</span>
    <span class="c1">#    return edges, ledges</span>

<div class="viewcode-block" id="topotyper.set_atom2bb"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.set_atom2bb">[docs]</a>    <span class="k">def</span> <span class="nf">set_atom2bb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;from atom index to building block the atom belongs to&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abb</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">natoms</span>
        <span class="k">for</span> <span class="n">ibb</span><span class="p">,</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">ibb</span>
        <span class="k">return</span></div>

    <span class="c1">### DOES NOT WORK W/O detect_all_connector</span>
    <span class="c1">#def set_conn2bb(self):</span>
    <span class="c1">#    &quot;&quot;&quot;from connector index to building block the atom connects&quot;&quot;&quot;</span>
    <span class="c1">#    self.conn2bb = [None]*self.mg.mol.natoms</span>
    <span class="c1">#    for bba in self.bb2adj:</span>
    <span class="c1">#        for c,ca in bba.items():</span>
    <span class="c1">#            self.conn2bb[c] = self.abb[ca]</span>
    <span class="c1">#    return</span>

<div class="viewcode-block" id="topotyper.determine_all_color"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.determine_all_color">[docs]</a>    <span class="k">def</span> <span class="nf">determine_all_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtype</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;determines colors according to element sequences</span>
<span class="sd">        from connectors to blocks&quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">edcol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elemseqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">elemseq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_elemseq</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">vtype</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
            <span class="n">elemseqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elemseq</span><span class="p">)</span>
        <span class="n">unique_elemseqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="n">elemseqs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">es</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_elemseqs</span><span class="p">:</span>
                <span class="n">unique_elemseqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
            <span class="n">edcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_elemseqs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">es</span><span class="p">))</span> <span class="c1">###SLOW</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edcol</span> <span class="o">=</span> <span class="n">edcol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elemseqs</span> <span class="o">=</span> <span class="n">elemseqs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unique_elemseqs</span> <span class="o">=</span> <span class="n">unique_elemseqs</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="topotyper.set_bb2ubb"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.set_bb2ubb">[docs]</a>    <span class="k">def</span> <span class="nf">set_bb2ubb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;from building block index to unique building block&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nbbs</span>
        <span class="k">for</span> <span class="n">iu</span><span class="p">,</span><span class="n">ubb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unique_bbs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jbb</span> <span class="ow">in</span> <span class="n">ubb</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">jbb</span><span class="p">]</span> <span class="o">=</span> <span class="n">iu</span>
        <span class="k">return</span></div>
    
<div class="viewcode-block" id="topotyper.determine_elemseq"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.determine_elemseq">[docs]</a>    <span class="k">def</span> <span class="nf">determine_elemseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">vtype</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;N.B.: works only with 2 (0/1) colors</span>
<span class="sd">        TBI: any number of colors&quot;&quot;&quot;</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">elems</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bb2ubb</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">vtype</span><span class="p">:</span>
            <span class="n">ba</span><span class="p">,</span><span class="n">bb</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">###AKA### elif self.bb2ubb[edge[1]] == vtype:</span>
            <span class="n">bb</span><span class="p">,</span><span class="n">ba</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">for</span> <span class="n">atomseq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomseqs</span><span class="p">[</span><span class="n">ba</span><span class="p">]:</span>
            <span class="n">atomseq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">atomseq</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abb</span><span class="p">[</span><span class="n">atomseq</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">bb</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">elemseq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">laseq</span> <span class="o">=</span> <span class="n">atomseq</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="n">leseq</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">laseq</span><span class="p">:</span>
                <span class="n">leseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">leseq</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">elemseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leseq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elemseq</span></div>

<div class="viewcode-block" id="topotyper.get_vbb"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_vbb">[docs]</a>    <span class="k">def</span> <span class="nf">get_vbb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">xyz</span></div>
    
<div class="viewcode-block" id="topotyper.get_vconn"><a class="viewcode-back" href="../../../_api/molsys.util.html#molsys.util.toper.topotyper.get_vconn">[docs]</a>    <span class="k">def</span> <span class="nf">get_vconn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">conn</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Roberto Amabile, Johannes P. Duerholt, Julian Keupp, Rochus Schmid

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>